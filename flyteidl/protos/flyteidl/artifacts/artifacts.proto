syntax = "proto3";
package flyteidl.artifact;

option go_package = "github.com/flyteorg/flyte/flyteidl/gen/pb-go/flyteidl/artifacts";

import "google/protobuf/struct.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";

import "flyteidl/admin/launch_plan.proto";
import "flyteidl/core/literals.proto";
import "flyteidl/core/types.proto";
import "flyteidl/core/identifier.proto";
import "flyteidl/core/artifact_id.proto";
import "flyteidl/core/interface.proto";
import "flyteidl/event/cloudevents.proto";

message Artifact {
  core.ArtifactID artifact_id = 1;

  ArtifactSpec spec = 2;

  // references the tag field in ArtifactTag
  repeated string tags = 3;

  ArtifactSource source = 4;

  ArtifactMetadata metadata = 5;
}

message ArtifactMetadata {

  google.protobuf.Timestamp created_at = 1;

  // i.e. flyte://av0.1/org/project/domain/name
  // for now return without org but we're going to need to detect if there is an org there
  // this will support cross org serverless accounts (need to sanitize inputs, getting rid of any special characters)
  string uri = 2;
}

message CreateArtifactRequest {
  // Specify just project/domain on creation
  core.ArtifactKey artifact_key = 1;

  string version = 3;

  ArtifactSpec spec = 2;

  map<string, string> partitions = 4;

  google.protobuf.Timestamp time_partition_value = 5;

  ArtifactSource source = 6;
}

message ArtifactSource {
  core.WorkflowExecutionIdentifier workflow_execution = 1;
  string node_id = 2;
  core.Identifier task_id = 3;
  uint32 retry_attempt = 4;

  // Uploads, either from the UI or from the CLI, or FlyteRemote, will have this.
  string principal = 5;
}

message ArtifactSpec {
  core.Literal value = 1;

  // This type will not form part of the artifact key, so for user-named artifacts, if the user changes the type, but
  // forgets to change the name, that is okay. And the reason why this is a separate field is because adding the
  // type to all Literals is a lot of work.
  core.LiteralType type = 2;

  string short_description = 3;

  // Additional user metadata
  google.protobuf.Struct user_metadata = 4;
}

message Trigger {
  // This is a partial artifact ID that will be triggered on
  core.ArtifactID trigger = 1;

  core.ParameterMap trigger_inputs = 2;
}


message CreateArtifactResponse {
  Artifact artifact = 1;
}

message GetArtifactRequest {
  core.ArtifactQuery query = 1;

  // If false, then long_description is not returned.
  bool details = 2;
}

message GetArtifactResponse {
  Artifact artifact = 1;
}

message SearchOptions {
  // If true, this means a strict partition search. meaning if you don't specify the partition
  // field, that will mean, non-partitioned, rather than any partition.
  bool strict_partitions = 1;

  // If true, only one artifact per key will be returned. It will be the latest one by creation time.
  bool latest_by_key = 2;
}

message SearchArtifactsRequest {
  core.ArtifactKey artifact_key = 1;

  core.Partitions partitions = 2;

  google.protobuf.Timestamp time_partition_value = 3;

  string principal = 4;
  string version = 5;

  SearchOptions options = 6;

  string token = 7;
  int32 limit = 8;
}

message SearchArtifactsResponse {
  // If artifact specs are not requested, the resultant artifacts may be empty.
  repeated Artifact artifacts = 1;

  // continuation token if relevant.
  string token = 2;
}

message FindByWorkflowExecRequest {
  core.WorkflowExecutionIdentifier exec_id = 1;

  enum Direction {
    INPUTS = 0;
    OUTPUTS = 1;
  }

  Direction direction = 2;
}

// Aliases identify a particular version of an artifact. They are different than tags in that they
// have to be unique for a given artifact project/domain/name. That is, for a given project/domain/name/kind,
// at most one version can have any given value at any point.
message AddTagRequest {
  core.ArtifactID artifact_id = 1;

  string value = 2;

  // If true, and another version already has the specified kind/value, set this version instead
  bool overwrite = 3;
}

message AddTagResponse {}

message ActivateTriggerRequest {
  core.Identifier trigger_id = 1;
}

message ActivateTriggerResponse {}

message CreateTriggerRequest {
  admin.LaunchPlan trigger_launch_plan = 1;
}

message CreateTriggerResponse {}

message DeactivateTriggerRequest {
  // Note that Trigger IDs are now 1:1 with Launch Plan IDs
  core.Identifier trigger_id = 1;
}

message DeactivateTriggerResponse {}

message DeactivateAllTriggersRequest {}

message DeactivateAllTriggersResponse {
  uint64 num_deactivated = 1;
}

message ArtifactProducer {
  // These can be tasks, and workflows. Keeping track of the launch plans that a given workflow has is purely in
  // Admin's domain.
  core.Identifier entity_id = 1;

  core.VariableMap outputs = 2;
}

message RegisterProducerRequest {
  repeated ArtifactProducer producers = 1;
}

message ArtifactConsumer {
  // These should all be launch plan IDs
  core.Identifier entity_id = 1;

  core.ParameterMap inputs = 2;
}

message RegisterConsumerRequest {
  repeated ArtifactConsumer consumers = 1;
}

message RegisterResponse {}

message ExecutionInputsRequest {
  core.WorkflowExecutionIdentifier execution_id = 1;

  // can make this a map in the future, currently no need.
  repeated core.ArtifactID inputs = 2;
}

message ExecutionInputsResponse {}

message ListUsageRequest {
  core.ArtifactID artifact_id = 1;
}

message ListUsageResponse {
  repeated core.WorkflowExecutionIdentifier executions = 1;
}

service ArtifactRegistry {
  rpc CreateArtifact (CreateArtifactRequest) returns (CreateArtifactResponse) {}

  rpc GetArtifact (GetArtifactRequest) returns (GetArtifactResponse) {
    option (google.api.http) = {
      post: "/artifacts/api/v1/artifacts"
      body: "*"
    };
  }

  rpc SearchArtifacts (SearchArtifactsRequest) returns (SearchArtifactsResponse) {
    option (google.api.http) = {
      post: "/artifacts/api/v1/search"
      body: "*"
    };
  }

  rpc CreateTrigger (CreateTriggerRequest) returns (CreateTriggerResponse) {}

  rpc ActivateTrigger (ActivateTriggerRequest) returns (ActivateTriggerResponse) {
    option (google.api.http) = {
      post: "/artifacts/api/v1/trigger/activate"
      body: "*"
    };
  }

  rpc DeactivateTrigger (DeactivateTriggerRequest) returns (DeactivateTriggerResponse) {
    option (google.api.http) = {
      patch: "/artifacts/api/v1/trigger/deactivate"
      body: "*"
    };
  }

  rpc DeactivateAllTriggers (DeactivateAllTriggersRequest) returns (DeactivateAllTriggersResponse) {
    option (google.api.http) = {
      patch: "/artifacts/api/v1/trigger/deactivate/all"
      body: "*"
    };
  }

  rpc AddTag(AddTagRequest) returns (AddTagResponse) {}

  rpc RegisterProducer(RegisterProducerRequest) returns (RegisterResponse) {}

  rpc RegisterConsumer(RegisterConsumerRequest) returns (RegisterResponse) {}

  rpc SetExecutionInputs(ExecutionInputsRequest) returns (ExecutionInputsResponse) {}

  rpc FindByWorkflowExec (FindByWorkflowExecRequest) returns (SearchArtifactsResponse) {
    option (google.api.http) = {
      get: "/artifacts/api/v1/search/execution/{exec_id.project}/{exec_id.domain}/{exec_id.name}/{direction}"
    };
  }

  rpc ListUsage (ListUsageRequest) returns (ListUsageResponse) {
    option (google.api.http) = {
      get: "/artifacts/api/v1/usage/{artifact_id.artifact_key.project}/{artifact_id.artifact_key.domain}/{artifact_id.artifact_key.name}/{artifact_id.version}"
    };
  }
}
