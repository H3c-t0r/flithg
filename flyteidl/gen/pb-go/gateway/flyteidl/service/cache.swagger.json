{
  "swagger": "2.0",
  "info": {
    "title": "flyteidl/service/cache.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "CacheService"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/v1/cache/task_executions/{task_execution_id.node_execution_id.execution_id.project}/{task_execution_id.node_execution_id.execution_id.domain}/{task_execution_id.node_execution_id.execution_id.name}/{task_execution_id.node_execution_id.node_id}/{task_execution_id.task_id.project}/{task_execution_id.task_id.domain}/{task_execution_id.task_id.name}/{task_execution_id.task_id.version}/{task_execution_id.retry_attempt}": {
      "delete": {
        "summary": "Evicts all cached data for the referenced :ref:`ref_flyteidl.admin.TaskExecution`.",
        "operationId": "CacheService_EvictTaskExecutionCache",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/serviceEvictCacheResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "task_execution_id.node_execution_id.execution_id.project",
            "description": "Name of the project the resource belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_execution_id.node_execution_id.execution_id.domain",
            "description": "Name of the domain the resource belongs to.\nA domain can be considered as a subset within a specific project.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_execution_id.node_execution_id.execution_id.name",
            "description": "User or system provided value for the resource.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_execution_id.node_execution_id.node_id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_execution_id.task_id.project",
            "description": "Name of the project the resource belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_execution_id.task_id.domain",
            "description": "Name of the domain the resource belongs to.\nA domain can be considered as a subset within a specific project.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_execution_id.task_id.name",
            "description": "User provided value for the resource.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_execution_id.task_id.version",
            "description": "Specific version of the resource.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_execution_id.retry_attempt",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int64"
          },
          {
            "name": "task_execution_id.task_id.resource_type",
            "description": "Identifies the specific type of resource that this identifier corresponds to.\n\n - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects.\nEventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects \nin a similar manner to other Flyte objects",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "UNSPECIFIED",
              "TASK",
              "WORKFLOW",
              "LAUNCH_PLAN",
              "DATASET"
            ],
            "default": "UNSPECIFIED"
          },
          {
            "name": "task_execution_id.task_id.org",
            "description": "Optional, org key applied to the resource.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "task_execution_id.node_execution_id.execution_id.org",
            "description": "Optional, org key applied to the resource.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "CacheService"
        ]
      }
    }
  },
  "definitions": {
    "CacheEvictionErrorCode": {
      "type": "string",
      "enum": [
        "INTERNAL",
        "RESERVATION_NOT_ACQUIRED",
        "DATABASE_UPDATE_FAILED",
        "ARTIFACT_DELETE_FAILED",
        "RESERVATION_NOT_RELEASED"
      ],
      "default": "INTERNAL",
      "description": "Defines codes for distinguishing between errors encountered during cache eviction.\n\n - INTERNAL: Indicates a generic internal error occurred.\n - RESERVATION_NOT_ACQUIRED: Indicates no reservation could be acquired before deleting an artifact.\n - DATABASE_UPDATE_FAILED: Indicates updating the database entry related to the node execution failed.\n - ARTIFACT_DELETE_FAILED: Indicates deleting the artifact from datacatalog failed.\n - RESERVATION_NOT_RELEASED: Indicates the reservation previously acquired could not be released for an artifact."
    },
    "coreCacheEvictionError": {
      "type": "object",
      "properties": {
        "code": {
          "$ref": "#/definitions/CacheEvictionErrorCode",
          "description": "Error code to match type of cache eviction error encountered."
        },
        "message": {
          "type": "string",
          "description": "More detailed error message explaining the reason for the cache eviction failure."
        },
        "node_execution_id": {
          "$ref": "#/definitions/coreNodeExecutionIdentifier",
          "description": "ID of the node execution the cache eviction failed for."
        },
        "task_execution_id": {
          "$ref": "#/definitions/coreTaskExecutionIdentifier",
          "description": "ID of the task execution the cache eviction failed for (if the node execution was part of a task execution)."
        },
        "workflow_execution_id": {
          "$ref": "#/definitions/coreWorkflowExecutionIdentifier",
          "description": "ID of the workflow execution the cache eviction failed for (if the node execution was part of a workflow execution)."
        }
      },
      "description": "Error returned if eviction of cached output fails and should be re-tried by the user."
    },
    "coreCacheEvictionErrorList": {
      "type": "object",
      "properties": {
        "errors": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreCacheEvictionError"
          }
        }
      },
      "description": "List of :ref:`ref_flyteidl.core.CacheEvictionError` encountered during a cache eviction request."
    },
    "coreIdentifier": {
      "type": "object",
      "properties": {
        "resource_type": {
          "$ref": "#/definitions/coreResourceType",
          "description": "Identifies the specific type of resource that this identifier corresponds to."
        },
        "project": {
          "type": "string",
          "description": "Name of the project the resource belongs to."
        },
        "domain": {
          "type": "string",
          "description": "Name of the domain the resource belongs to.\nA domain can be considered as a subset within a specific project."
        },
        "name": {
          "type": "string",
          "description": "User provided value for the resource."
        },
        "version": {
          "type": "string",
          "description": "Specific version of the resource."
        },
        "org": {
          "type": "string",
          "description": "Optional, org key applied to the resource."
        }
      },
      "description": "Encapsulation of fields that uniquely identifies a Flyte resource."
    },
    "coreNodeExecutionIdentifier": {
      "type": "object",
      "properties": {
        "node_id": {
          "type": "string"
        },
        "execution_id": {
          "$ref": "#/definitions/coreWorkflowExecutionIdentifier"
        }
      },
      "description": "Encapsulation of fields that identify a Flyte node execution entity."
    },
    "coreResourceType": {
      "type": "string",
      "enum": [
        "UNSPECIFIED",
        "TASK",
        "WORKFLOW",
        "LAUNCH_PLAN",
        "DATASET"
      ],
      "default": "UNSPECIFIED",
      "description": "Indicates a resource type within Flyte.\n\n - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects.\nEventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects \nin a similar manner to other Flyte objects"
    },
    "coreTaskExecutionIdentifier": {
      "type": "object",
      "properties": {
        "task_id": {
          "$ref": "#/definitions/coreIdentifier"
        },
        "node_execution_id": {
          "$ref": "#/definitions/coreNodeExecutionIdentifier"
        },
        "retry_attempt": {
          "type": "integer",
          "format": "int64"
        }
      },
      "description": "Encapsulation of fields that identify a Flyte task execution entity."
    },
    "coreWorkflowExecutionIdentifier": {
      "type": "object",
      "properties": {
        "project": {
          "type": "string",
          "description": "Name of the project the resource belongs to."
        },
        "domain": {
          "type": "string",
          "description": "Name of the domain the resource belongs to.\nA domain can be considered as a subset within a specific project."
        },
        "name": {
          "type": "string",
          "description": "User or system provided value for the resource."
        },
        "org": {
          "type": "string",
          "description": "Optional, org key applied to the resource."
        }
      },
      "title": "Encapsulation of fields that uniquely identifies a Flyte workflow execution"
    },
    "googlerpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "serviceEvictCacheResponse": {
      "type": "object",
      "properties": {
        "errors": {
          "$ref": "#/definitions/coreCacheEvictionErrorList",
          "description": "List of errors encountered during cache eviction (if any)."
        }
      }
    }
  }
}
