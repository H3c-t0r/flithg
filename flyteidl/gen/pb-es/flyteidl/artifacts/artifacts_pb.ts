// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file flyteidl/artifacts/artifacts.proto (package flyteidl.artifact, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct, Timestamp } from "@bufbuild/protobuf";
import { ArtifactID, ArtifactKey, ArtifactQuery, Partitions } from "../core/artifact_id_pb.js";
import { Identifier, WorkflowExecutionIdentifier } from "../core/identifier_pb.js";
import { Literal } from "../core/literals_pb.js";
import { LiteralType } from "../core/types_pb.js";
import { ParameterMap, VariableMap } from "../core/interface_pb.js";
import { LaunchPlan } from "../admin/launch_plan_pb.js";

/**
 * @generated from message flyteidl.artifact.Artifact
 */
export class Artifact extends Message<Artifact> {
  /**
   * @generated from field: flyteidl.core.ArtifactID artifact_id = 1;
   */
  artifactId?: ArtifactID;

  /**
   * @generated from field: flyteidl.artifact.ArtifactSpec spec = 2;
   */
  spec?: ArtifactSpec;

  /**
   * references the tag field in ArtifactTag
   *
   * @generated from field: repeated string tags = 3;
   */
  tags: string[] = [];

  /**
   * @generated from field: flyteidl.artifact.ArtifactSource source = 4;
   */
  source?: ArtifactSource;

  /**
   * @generated from field: flyteidl.artifact.ArtifactMetadata metadata = 5;
   */
  metadata?: ArtifactMetadata;

  constructor(data?: PartialMessage<Artifact>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.Artifact";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "artifact_id", kind: "message", T: ArtifactID },
    { no: 2, name: "spec", kind: "message", T: ArtifactSpec },
    { no: 3, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "source", kind: "message", T: ArtifactSource },
    { no: 5, name: "metadata", kind: "message", T: ArtifactMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Artifact {
    return new Artifact().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Artifact {
    return new Artifact().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Artifact {
    return new Artifact().fromJsonString(jsonString, options);
  }

  static equals(a: Artifact | PlainMessage<Artifact> | undefined, b: Artifact | PlainMessage<Artifact> | undefined): boolean {
    return proto3.util.equals(Artifact, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ArtifactMetadata
 */
export class ArtifactMetadata extends Message<ArtifactMetadata> {
  /**
   * @generated from field: google.protobuf.Timestamp created_at = 1;
   */
  createdAt?: Timestamp;

  /**
   * i.e. flyte://av0.1/org/project/domain/name
   * for now return without org but we're going to need to detect if there is an org there
   * this will support cross org serverless accounts (need to sanitize inputs, getting rid of any special characters)
   *
   * @generated from field: string uri = 2;
   */
  uri = "";

  constructor(data?: PartialMessage<ArtifactMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ArtifactMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "created_at", kind: "message", T: Timestamp },
    { no: 2, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArtifactMetadata {
    return new ArtifactMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArtifactMetadata {
    return new ArtifactMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArtifactMetadata {
    return new ArtifactMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ArtifactMetadata | PlainMessage<ArtifactMetadata> | undefined, b: ArtifactMetadata | PlainMessage<ArtifactMetadata> | undefined): boolean {
    return proto3.util.equals(ArtifactMetadata, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.CreateArtifactRequest
 */
export class CreateArtifactRequest extends Message<CreateArtifactRequest> {
  /**
   * Specify just project/domain on creation
   *
   * @generated from field: flyteidl.core.ArtifactKey artifact_key = 1;
   */
  artifactKey?: ArtifactKey;

  /**
   * @generated from field: string version = 3;
   */
  version = "";

  /**
   * @generated from field: flyteidl.artifact.ArtifactSpec spec = 2;
   */
  spec?: ArtifactSpec;

  /**
   * @generated from field: map<string, string> partitions = 4;
   */
  partitions: { [key: string]: string } = {};

  /**
   * @generated from field: google.protobuf.Timestamp time_partition_value = 5;
   */
  timePartitionValue?: Timestamp;

  /**
   * @generated from field: flyteidl.artifact.ArtifactSource source = 6;
   */
  source?: ArtifactSource;

  constructor(data?: PartialMessage<CreateArtifactRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.CreateArtifactRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "artifact_key", kind: "message", T: ArtifactKey },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "spec", kind: "message", T: ArtifactSpec },
    { no: 4, name: "partitions", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "time_partition_value", kind: "message", T: Timestamp },
    { no: 6, name: "source", kind: "message", T: ArtifactSource },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateArtifactRequest {
    return new CreateArtifactRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateArtifactRequest {
    return new CreateArtifactRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateArtifactRequest {
    return new CreateArtifactRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateArtifactRequest | PlainMessage<CreateArtifactRequest> | undefined, b: CreateArtifactRequest | PlainMessage<CreateArtifactRequest> | undefined): boolean {
    return proto3.util.equals(CreateArtifactRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ArtifactSource
 */
export class ArtifactSource extends Message<ArtifactSource> {
  /**
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier workflow_execution = 1;
   */
  workflowExecution?: WorkflowExecutionIdentifier;

  /**
   * @generated from field: string node_id = 2;
   */
  nodeId = "";

  /**
   * @generated from field: flyteidl.core.Identifier task_id = 3;
   */
  taskId?: Identifier;

  /**
   * @generated from field: uint32 retry_attempt = 4;
   */
  retryAttempt = 0;

  /**
   * Uploads, either from the UI or from the CLI, or FlyteRemote, will have this.
   *
   * @generated from field: string principal = 5;
   */
  principal = "";

  constructor(data?: PartialMessage<ArtifactSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ArtifactSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_execution", kind: "message", T: WorkflowExecutionIdentifier },
    { no: 2, name: "node_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "task_id", kind: "message", T: Identifier },
    { no: 4, name: "retry_attempt", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "principal", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArtifactSource {
    return new ArtifactSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArtifactSource {
    return new ArtifactSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArtifactSource {
    return new ArtifactSource().fromJsonString(jsonString, options);
  }

  static equals(a: ArtifactSource | PlainMessage<ArtifactSource> | undefined, b: ArtifactSource | PlainMessage<ArtifactSource> | undefined): boolean {
    return proto3.util.equals(ArtifactSource, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ArtifactSpec
 */
export class ArtifactSpec extends Message<ArtifactSpec> {
  /**
   * @generated from field: flyteidl.core.Literal value = 1;
   */
  value?: Literal;

  /**
   * This type will not form part of the artifact key, so for user-named artifacts, if the user changes the type, but
   * forgets to change the name, that is okay. And the reason why this is a separate field is because adding the
   * type to all Literals is a lot of work.
   *
   * @generated from field: flyteidl.core.LiteralType type = 2;
   */
  type?: LiteralType;

  /**
   * @generated from field: string short_description = 3;
   */
  shortDescription = "";

  /**
   * Additional user metadata
   *
   * @generated from field: google.protobuf.Struct user_metadata = 4;
   */
  userMetadata?: Struct;

  constructor(data?: PartialMessage<ArtifactSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ArtifactSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: Literal },
    { no: 2, name: "type", kind: "message", T: LiteralType },
    { no: 3, name: "short_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "user_metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArtifactSpec {
    return new ArtifactSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArtifactSpec {
    return new ArtifactSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArtifactSpec {
    return new ArtifactSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ArtifactSpec | PlainMessage<ArtifactSpec> | undefined, b: ArtifactSpec | PlainMessage<ArtifactSpec> | undefined): boolean {
    return proto3.util.equals(ArtifactSpec, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.Trigger
 */
export class Trigger extends Message<Trigger> {
  /**
   * This is a partial artifact ID that will be triggered on
   *
   * @generated from field: flyteidl.core.ArtifactID trigger = 1;
   */
  trigger?: ArtifactID;

  /**
   * @generated from field: flyteidl.core.ParameterMap trigger_inputs = 2;
   */
  triggerInputs?: ParameterMap;

  constructor(data?: PartialMessage<Trigger>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.Trigger";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trigger", kind: "message", T: ArtifactID },
    { no: 2, name: "trigger_inputs", kind: "message", T: ParameterMap },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Trigger {
    return new Trigger().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Trigger {
    return new Trigger().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Trigger {
    return new Trigger().fromJsonString(jsonString, options);
  }

  static equals(a: Trigger | PlainMessage<Trigger> | undefined, b: Trigger | PlainMessage<Trigger> | undefined): boolean {
    return proto3.util.equals(Trigger, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.CreateArtifactResponse
 */
export class CreateArtifactResponse extends Message<CreateArtifactResponse> {
  /**
   * @generated from field: flyteidl.artifact.Artifact artifact = 1;
   */
  artifact?: Artifact;

  constructor(data?: PartialMessage<CreateArtifactResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.CreateArtifactResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "artifact", kind: "message", T: Artifact },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateArtifactResponse {
    return new CreateArtifactResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateArtifactResponse {
    return new CreateArtifactResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateArtifactResponse {
    return new CreateArtifactResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateArtifactResponse | PlainMessage<CreateArtifactResponse> | undefined, b: CreateArtifactResponse | PlainMessage<CreateArtifactResponse> | undefined): boolean {
    return proto3.util.equals(CreateArtifactResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.GetArtifactRequest
 */
export class GetArtifactRequest extends Message<GetArtifactRequest> {
  /**
   * @generated from field: flyteidl.core.ArtifactQuery query = 1;
   */
  query?: ArtifactQuery;

  /**
   * If false, then long_description is not returned.
   *
   * @generated from field: bool details = 2;
   */
  details = false;

  constructor(data?: PartialMessage<GetArtifactRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.GetArtifactRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "message", T: ArtifactQuery },
    { no: 2, name: "details", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetArtifactRequest {
    return new GetArtifactRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetArtifactRequest {
    return new GetArtifactRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetArtifactRequest {
    return new GetArtifactRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetArtifactRequest | PlainMessage<GetArtifactRequest> | undefined, b: GetArtifactRequest | PlainMessage<GetArtifactRequest> | undefined): boolean {
    return proto3.util.equals(GetArtifactRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.GetArtifactResponse
 */
export class GetArtifactResponse extends Message<GetArtifactResponse> {
  /**
   * @generated from field: flyteidl.artifact.Artifact artifact = 1;
   */
  artifact?: Artifact;

  constructor(data?: PartialMessage<GetArtifactResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.GetArtifactResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "artifact", kind: "message", T: Artifact },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetArtifactResponse {
    return new GetArtifactResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetArtifactResponse {
    return new GetArtifactResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetArtifactResponse {
    return new GetArtifactResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetArtifactResponse | PlainMessage<GetArtifactResponse> | undefined, b: GetArtifactResponse | PlainMessage<GetArtifactResponse> | undefined): boolean {
    return proto3.util.equals(GetArtifactResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.SearchOptions
 */
export class SearchOptions extends Message<SearchOptions> {
  /**
   * If true, this means a strict partition search. meaning if you don't specify the partition
   * field, that will mean, non-partitioned, rather than any partition.
   *
   * @generated from field: bool strict_partitions = 1;
   */
  strictPartitions = false;

  /**
   * If true, only one artifact per key will be returned. It will be the latest one by creation time.
   *
   * @generated from field: bool latest_by_key = 2;
   */
  latestByKey = false;

  constructor(data?: PartialMessage<SearchOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.SearchOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "strict_partitions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "latest_by_key", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchOptions {
    return new SearchOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchOptions {
    return new SearchOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchOptions {
    return new SearchOptions().fromJsonString(jsonString, options);
  }

  static equals(a: SearchOptions | PlainMessage<SearchOptions> | undefined, b: SearchOptions | PlainMessage<SearchOptions> | undefined): boolean {
    return proto3.util.equals(SearchOptions, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.SearchArtifactsRequest
 */
export class SearchArtifactsRequest extends Message<SearchArtifactsRequest> {
  /**
   * @generated from field: flyteidl.core.ArtifactKey artifact_key = 1;
   */
  artifactKey?: ArtifactKey;

  /**
   * @generated from field: flyteidl.core.Partitions partitions = 2;
   */
  partitions?: Partitions;

  /**
   * @generated from field: google.protobuf.Timestamp time_partition_value = 3;
   */
  timePartitionValue?: Timestamp;

  /**
   * @generated from field: string principal = 4;
   */
  principal = "";

  /**
   * @generated from field: string version = 5;
   */
  version = "";

  /**
   * @generated from field: flyteidl.artifact.SearchOptions options = 6;
   */
  options?: SearchOptions;

  /**
   * @generated from field: string token = 7;
   */
  token = "";

  /**
   * @generated from field: int32 limit = 8;
   */
  limit = 0;

  constructor(data?: PartialMessage<SearchArtifactsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.SearchArtifactsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "artifact_key", kind: "message", T: ArtifactKey },
    { no: 2, name: "partitions", kind: "message", T: Partitions },
    { no: 3, name: "time_partition_value", kind: "message", T: Timestamp },
    { no: 4, name: "principal", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "options", kind: "message", T: SearchOptions },
    { no: 7, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchArtifactsRequest {
    return new SearchArtifactsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchArtifactsRequest {
    return new SearchArtifactsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchArtifactsRequest {
    return new SearchArtifactsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchArtifactsRequest | PlainMessage<SearchArtifactsRequest> | undefined, b: SearchArtifactsRequest | PlainMessage<SearchArtifactsRequest> | undefined): boolean {
    return proto3.util.equals(SearchArtifactsRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.SearchArtifactsResponse
 */
export class SearchArtifactsResponse extends Message<SearchArtifactsResponse> {
  /**
   * If artifact specs are not requested, the resultant artifacts may be empty.
   *
   * @generated from field: repeated flyteidl.artifact.Artifact artifacts = 1;
   */
  artifacts: Artifact[] = [];

  /**
   * continuation token if relevant.
   *
   * @generated from field: string token = 2;
   */
  token = "";

  constructor(data?: PartialMessage<SearchArtifactsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.SearchArtifactsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "artifacts", kind: "message", T: Artifact, repeated: true },
    { no: 2, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchArtifactsResponse {
    return new SearchArtifactsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchArtifactsResponse {
    return new SearchArtifactsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchArtifactsResponse {
    return new SearchArtifactsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchArtifactsResponse | PlainMessage<SearchArtifactsResponse> | undefined, b: SearchArtifactsResponse | PlainMessage<SearchArtifactsResponse> | undefined): boolean {
    return proto3.util.equals(SearchArtifactsResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.FindByWorkflowExecRequest
 */
export class FindByWorkflowExecRequest extends Message<FindByWorkflowExecRequest> {
  /**
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier exec_id = 1;
   */
  execId?: WorkflowExecutionIdentifier;

  /**
   * @generated from field: flyteidl.artifact.FindByWorkflowExecRequest.Direction direction = 2;
   */
  direction = FindByWorkflowExecRequest_Direction.INPUTS;

  constructor(data?: PartialMessage<FindByWorkflowExecRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.FindByWorkflowExecRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exec_id", kind: "message", T: WorkflowExecutionIdentifier },
    { no: 2, name: "direction", kind: "enum", T: proto3.getEnumType(FindByWorkflowExecRequest_Direction) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindByWorkflowExecRequest {
    return new FindByWorkflowExecRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindByWorkflowExecRequest {
    return new FindByWorkflowExecRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindByWorkflowExecRequest {
    return new FindByWorkflowExecRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FindByWorkflowExecRequest | PlainMessage<FindByWorkflowExecRequest> | undefined, b: FindByWorkflowExecRequest | PlainMessage<FindByWorkflowExecRequest> | undefined): boolean {
    return proto3.util.equals(FindByWorkflowExecRequest, a, b);
  }
}

/**
 * @generated from enum flyteidl.artifact.FindByWorkflowExecRequest.Direction
 */
export enum FindByWorkflowExecRequest_Direction {
  /**
   * @generated from enum value: INPUTS = 0;
   */
  INPUTS = 0,

  /**
   * @generated from enum value: OUTPUTS = 1;
   */
  OUTPUTS = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(FindByWorkflowExecRequest_Direction)
proto3.util.setEnumType(FindByWorkflowExecRequest_Direction, "flyteidl.artifact.FindByWorkflowExecRequest.Direction", [
  { no: 0, name: "INPUTS" },
  { no: 1, name: "OUTPUTS" },
]);

/**
 * Aliases identify a particular version of an artifact. They are different than tags in that they
 * have to be unique for a given artifact project/domain/name. That is, for a given project/domain/name/kind,
 * at most one version can have any given value at any point.
 *
 * @generated from message flyteidl.artifact.AddTagRequest
 */
export class AddTagRequest extends Message<AddTagRequest> {
  /**
   * @generated from field: flyteidl.core.ArtifactID artifact_id = 1;
   */
  artifactId?: ArtifactID;

  /**
   * @generated from field: string value = 2;
   */
  value = "";

  /**
   * If true, and another version already has the specified kind/value, set this version instead
   *
   * @generated from field: bool overwrite = 3;
   */
  overwrite = false;

  constructor(data?: PartialMessage<AddTagRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.AddTagRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "artifact_id", kind: "message", T: ArtifactID },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "overwrite", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddTagRequest {
    return new AddTagRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddTagRequest {
    return new AddTagRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddTagRequest {
    return new AddTagRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AddTagRequest | PlainMessage<AddTagRequest> | undefined, b: AddTagRequest | PlainMessage<AddTagRequest> | undefined): boolean {
    return proto3.util.equals(AddTagRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.AddTagResponse
 */
export class AddTagResponse extends Message<AddTagResponse> {
  constructor(data?: PartialMessage<AddTagResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.AddTagResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddTagResponse {
    return new AddTagResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddTagResponse {
    return new AddTagResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddTagResponse {
    return new AddTagResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AddTagResponse | PlainMessage<AddTagResponse> | undefined, b: AddTagResponse | PlainMessage<AddTagResponse> | undefined): boolean {
    return proto3.util.equals(AddTagResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ActivateTriggerRequest
 */
export class ActivateTriggerRequest extends Message<ActivateTriggerRequest> {
  /**
   * @generated from field: flyteidl.core.Identifier trigger_id = 1;
   */
  triggerId?: Identifier;

  constructor(data?: PartialMessage<ActivateTriggerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ActivateTriggerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trigger_id", kind: "message", T: Identifier },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivateTriggerRequest {
    return new ActivateTriggerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivateTriggerRequest {
    return new ActivateTriggerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivateTriggerRequest {
    return new ActivateTriggerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ActivateTriggerRequest | PlainMessage<ActivateTriggerRequest> | undefined, b: ActivateTriggerRequest | PlainMessage<ActivateTriggerRequest> | undefined): boolean {
    return proto3.util.equals(ActivateTriggerRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ActivateTriggerResponse
 */
export class ActivateTriggerResponse extends Message<ActivateTriggerResponse> {
  constructor(data?: PartialMessage<ActivateTriggerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ActivateTriggerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivateTriggerResponse {
    return new ActivateTriggerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivateTriggerResponse {
    return new ActivateTriggerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivateTriggerResponse {
    return new ActivateTriggerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ActivateTriggerResponse | PlainMessage<ActivateTriggerResponse> | undefined, b: ActivateTriggerResponse | PlainMessage<ActivateTriggerResponse> | undefined): boolean {
    return proto3.util.equals(ActivateTriggerResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.CreateTriggerRequest
 */
export class CreateTriggerRequest extends Message<CreateTriggerRequest> {
  /**
   * @generated from field: flyteidl.admin.LaunchPlan trigger_launch_plan = 1;
   */
  triggerLaunchPlan?: LaunchPlan;

  constructor(data?: PartialMessage<CreateTriggerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.CreateTriggerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trigger_launch_plan", kind: "message", T: LaunchPlan },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateTriggerRequest {
    return new CreateTriggerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateTriggerRequest {
    return new CreateTriggerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateTriggerRequest {
    return new CreateTriggerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateTriggerRequest | PlainMessage<CreateTriggerRequest> | undefined, b: CreateTriggerRequest | PlainMessage<CreateTriggerRequest> | undefined): boolean {
    return proto3.util.equals(CreateTriggerRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.CreateTriggerResponse
 */
export class CreateTriggerResponse extends Message<CreateTriggerResponse> {
  constructor(data?: PartialMessage<CreateTriggerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.CreateTriggerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateTriggerResponse {
    return new CreateTriggerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateTriggerResponse {
    return new CreateTriggerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateTriggerResponse {
    return new CreateTriggerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateTriggerResponse | PlainMessage<CreateTriggerResponse> | undefined, b: CreateTriggerResponse | PlainMessage<CreateTriggerResponse> | undefined): boolean {
    return proto3.util.equals(CreateTriggerResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.DeactivateTriggerRequest
 */
export class DeactivateTriggerRequest extends Message<DeactivateTriggerRequest> {
  /**
   * Note that Trigger IDs are now 1:1 with Launch Plan IDs
   *
   * @generated from field: flyteidl.core.Identifier trigger_id = 1;
   */
  triggerId?: Identifier;

  constructor(data?: PartialMessage<DeactivateTriggerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.DeactivateTriggerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trigger_id", kind: "message", T: Identifier },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeactivateTriggerRequest {
    return new DeactivateTriggerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeactivateTriggerRequest {
    return new DeactivateTriggerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeactivateTriggerRequest {
    return new DeactivateTriggerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeactivateTriggerRequest | PlainMessage<DeactivateTriggerRequest> | undefined, b: DeactivateTriggerRequest | PlainMessage<DeactivateTriggerRequest> | undefined): boolean {
    return proto3.util.equals(DeactivateTriggerRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.DeactivateTriggerResponse
 */
export class DeactivateTriggerResponse extends Message<DeactivateTriggerResponse> {
  constructor(data?: PartialMessage<DeactivateTriggerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.DeactivateTriggerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeactivateTriggerResponse {
    return new DeactivateTriggerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeactivateTriggerResponse {
    return new DeactivateTriggerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeactivateTriggerResponse {
    return new DeactivateTriggerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeactivateTriggerResponse | PlainMessage<DeactivateTriggerResponse> | undefined, b: DeactivateTriggerResponse | PlainMessage<DeactivateTriggerResponse> | undefined): boolean {
    return proto3.util.equals(DeactivateTriggerResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.DeactivateAllTriggersRequest
 */
export class DeactivateAllTriggersRequest extends Message<DeactivateAllTriggersRequest> {
  constructor(data?: PartialMessage<DeactivateAllTriggersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.DeactivateAllTriggersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeactivateAllTriggersRequest {
    return new DeactivateAllTriggersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeactivateAllTriggersRequest {
    return new DeactivateAllTriggersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeactivateAllTriggersRequest {
    return new DeactivateAllTriggersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeactivateAllTriggersRequest | PlainMessage<DeactivateAllTriggersRequest> | undefined, b: DeactivateAllTriggersRequest | PlainMessage<DeactivateAllTriggersRequest> | undefined): boolean {
    return proto3.util.equals(DeactivateAllTriggersRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.DeactivateAllTriggersResponse
 */
export class DeactivateAllTriggersResponse extends Message<DeactivateAllTriggersResponse> {
  /**
   * @generated from field: uint64 num_deactivated = 1;
   */
  numDeactivated = protoInt64.zero;

  constructor(data?: PartialMessage<DeactivateAllTriggersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.DeactivateAllTriggersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_deactivated", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeactivateAllTriggersResponse {
    return new DeactivateAllTriggersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeactivateAllTriggersResponse {
    return new DeactivateAllTriggersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeactivateAllTriggersResponse {
    return new DeactivateAllTriggersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeactivateAllTriggersResponse | PlainMessage<DeactivateAllTriggersResponse> | undefined, b: DeactivateAllTriggersResponse | PlainMessage<DeactivateAllTriggersResponse> | undefined): boolean {
    return proto3.util.equals(DeactivateAllTriggersResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ArtifactProducer
 */
export class ArtifactProducer extends Message<ArtifactProducer> {
  /**
   * These can be tasks, and workflows. Keeping track of the launch plans that a given workflow has is purely in
   * Admin's domain.
   *
   * @generated from field: flyteidl.core.Identifier entity_id = 1;
   */
  entityId?: Identifier;

  /**
   * @generated from field: flyteidl.core.VariableMap outputs = 2;
   */
  outputs?: VariableMap;

  constructor(data?: PartialMessage<ArtifactProducer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ArtifactProducer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "message", T: Identifier },
    { no: 2, name: "outputs", kind: "message", T: VariableMap },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArtifactProducer {
    return new ArtifactProducer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArtifactProducer {
    return new ArtifactProducer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArtifactProducer {
    return new ArtifactProducer().fromJsonString(jsonString, options);
  }

  static equals(a: ArtifactProducer | PlainMessage<ArtifactProducer> | undefined, b: ArtifactProducer | PlainMessage<ArtifactProducer> | undefined): boolean {
    return proto3.util.equals(ArtifactProducer, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.RegisterProducerRequest
 */
export class RegisterProducerRequest extends Message<RegisterProducerRequest> {
  /**
   * @generated from field: repeated flyteidl.artifact.ArtifactProducer producers = 1;
   */
  producers: ArtifactProducer[] = [];

  constructor(data?: PartialMessage<RegisterProducerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.RegisterProducerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "producers", kind: "message", T: ArtifactProducer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterProducerRequest {
    return new RegisterProducerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterProducerRequest {
    return new RegisterProducerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterProducerRequest {
    return new RegisterProducerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterProducerRequest | PlainMessage<RegisterProducerRequest> | undefined, b: RegisterProducerRequest | PlainMessage<RegisterProducerRequest> | undefined): boolean {
    return proto3.util.equals(RegisterProducerRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ArtifactConsumer
 */
export class ArtifactConsumer extends Message<ArtifactConsumer> {
  /**
   * These should all be launch plan IDs
   *
   * @generated from field: flyteidl.core.Identifier entity_id = 1;
   */
  entityId?: Identifier;

  /**
   * @generated from field: flyteidl.core.ParameterMap inputs = 2;
   */
  inputs?: ParameterMap;

  constructor(data?: PartialMessage<ArtifactConsumer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ArtifactConsumer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "message", T: Identifier },
    { no: 2, name: "inputs", kind: "message", T: ParameterMap },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArtifactConsumer {
    return new ArtifactConsumer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArtifactConsumer {
    return new ArtifactConsumer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArtifactConsumer {
    return new ArtifactConsumer().fromJsonString(jsonString, options);
  }

  static equals(a: ArtifactConsumer | PlainMessage<ArtifactConsumer> | undefined, b: ArtifactConsumer | PlainMessage<ArtifactConsumer> | undefined): boolean {
    return proto3.util.equals(ArtifactConsumer, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.RegisterConsumerRequest
 */
export class RegisterConsumerRequest extends Message<RegisterConsumerRequest> {
  /**
   * @generated from field: repeated flyteidl.artifact.ArtifactConsumer consumers = 1;
   */
  consumers: ArtifactConsumer[] = [];

  constructor(data?: PartialMessage<RegisterConsumerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.RegisterConsumerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consumers", kind: "message", T: ArtifactConsumer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterConsumerRequest {
    return new RegisterConsumerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterConsumerRequest {
    return new RegisterConsumerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterConsumerRequest {
    return new RegisterConsumerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterConsumerRequest | PlainMessage<RegisterConsumerRequest> | undefined, b: RegisterConsumerRequest | PlainMessage<RegisterConsumerRequest> | undefined): boolean {
    return proto3.util.equals(RegisterConsumerRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.RegisterResponse
 */
export class RegisterResponse extends Message<RegisterResponse> {
  constructor(data?: PartialMessage<RegisterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.RegisterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterResponse {
    return new RegisterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterResponse {
    return new RegisterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterResponse {
    return new RegisterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterResponse | PlainMessage<RegisterResponse> | undefined, b: RegisterResponse | PlainMessage<RegisterResponse> | undefined): boolean {
    return proto3.util.equals(RegisterResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ExecutionInputsRequest
 */
export class ExecutionInputsRequest extends Message<ExecutionInputsRequest> {
  /**
   * @generated from field: flyteidl.core.WorkflowExecutionIdentifier execution_id = 1;
   */
  executionId?: WorkflowExecutionIdentifier;

  /**
   * can make this a map in the future, currently no need.
   *
   * @generated from field: repeated flyteidl.core.ArtifactID inputs = 2;
   */
  inputs: ArtifactID[] = [];

  constructor(data?: PartialMessage<ExecutionInputsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ExecutionInputsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "execution_id", kind: "message", T: WorkflowExecutionIdentifier },
    { no: 2, name: "inputs", kind: "message", T: ArtifactID, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionInputsRequest {
    return new ExecutionInputsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionInputsRequest {
    return new ExecutionInputsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionInputsRequest {
    return new ExecutionInputsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExecutionInputsRequest | PlainMessage<ExecutionInputsRequest> | undefined, b: ExecutionInputsRequest | PlainMessage<ExecutionInputsRequest> | undefined): boolean {
    return proto3.util.equals(ExecutionInputsRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ExecutionInputsResponse
 */
export class ExecutionInputsResponse extends Message<ExecutionInputsResponse> {
  constructor(data?: PartialMessage<ExecutionInputsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ExecutionInputsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionInputsResponse {
    return new ExecutionInputsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionInputsResponse {
    return new ExecutionInputsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionInputsResponse {
    return new ExecutionInputsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExecutionInputsResponse | PlainMessage<ExecutionInputsResponse> | undefined, b: ExecutionInputsResponse | PlainMessage<ExecutionInputsResponse> | undefined): boolean {
    return proto3.util.equals(ExecutionInputsResponse, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ListUsageRequest
 */
export class ListUsageRequest extends Message<ListUsageRequest> {
  /**
   * @generated from field: flyteidl.core.ArtifactID artifact_id = 1;
   */
  artifactId?: ArtifactID;

  constructor(data?: PartialMessage<ListUsageRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ListUsageRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "artifact_id", kind: "message", T: ArtifactID },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUsageRequest {
    return new ListUsageRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUsageRequest {
    return new ListUsageRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUsageRequest {
    return new ListUsageRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListUsageRequest | PlainMessage<ListUsageRequest> | undefined, b: ListUsageRequest | PlainMessage<ListUsageRequest> | undefined): boolean {
    return proto3.util.equals(ListUsageRequest, a, b);
  }
}

/**
 * @generated from message flyteidl.artifact.ListUsageResponse
 */
export class ListUsageResponse extends Message<ListUsageResponse> {
  /**
   * @generated from field: repeated flyteidl.core.WorkflowExecutionIdentifier executions = 1;
   */
  executions: WorkflowExecutionIdentifier[] = [];

  constructor(data?: PartialMessage<ListUsageResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.artifact.ListUsageResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "executions", kind: "message", T: WorkflowExecutionIdentifier, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUsageResponse {
    return new ListUsageResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUsageResponse {
    return new ListUsageResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUsageResponse {
    return new ListUsageResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListUsageResponse | PlainMessage<ListUsageResponse> | undefined, b: ListUsageResponse | PlainMessage<ListUsageResponse> | undefined): boolean {
    return proto3.util.equals(ListUsageResponse, a, b);
  }
}

