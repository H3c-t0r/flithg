// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/artifact/artifacts.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fartifact_2fartifacts_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fartifact_2fartifacts_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "google/api/annotations.pb.h"
#include "flyteidl/admin/launch_plan.pb.h"
#include "flyteidl/core/literals.pb.h"
#include "flyteidl/core/types.pb.h"
#include "flyteidl/core/identifier.pb.h"
#include "flyteidl/core/artifact_id.pb.h"
#include "flyteidl/core/interface.pb.h"
#include "flyteidl/event/cloudevents.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fartifact_2fartifacts_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fartifact_2fartifacts_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fartifact_2fartifacts_2eproto();
namespace flyteidl {
namespace artifact {
class AddTagRequest;
class AddTagRequestDefaultTypeInternal;
extern AddTagRequestDefaultTypeInternal _AddTagRequest_default_instance_;
class AddTagResponse;
class AddTagResponseDefaultTypeInternal;
extern AddTagResponseDefaultTypeInternal _AddTagResponse_default_instance_;
class Artifact;
class ArtifactDefaultTypeInternal;
extern ArtifactDefaultTypeInternal _Artifact_default_instance_;
class ArtifactConsumer;
class ArtifactConsumerDefaultTypeInternal;
extern ArtifactConsumerDefaultTypeInternal _ArtifactConsumer_default_instance_;
class ArtifactProducer;
class ArtifactProducerDefaultTypeInternal;
extern ArtifactProducerDefaultTypeInternal _ArtifactProducer_default_instance_;
class ArtifactSource;
class ArtifactSourceDefaultTypeInternal;
extern ArtifactSourceDefaultTypeInternal _ArtifactSource_default_instance_;
class ArtifactSpec;
class ArtifactSpecDefaultTypeInternal;
extern ArtifactSpecDefaultTypeInternal _ArtifactSpec_default_instance_;
class CreateArtifactRequest;
class CreateArtifactRequestDefaultTypeInternal;
extern CreateArtifactRequestDefaultTypeInternal _CreateArtifactRequest_default_instance_;
class CreateArtifactRequest_PartitionsEntry_DoNotUse;
class CreateArtifactRequest_PartitionsEntry_DoNotUseDefaultTypeInternal;
extern CreateArtifactRequest_PartitionsEntry_DoNotUseDefaultTypeInternal _CreateArtifactRequest_PartitionsEntry_DoNotUse_default_instance_;
class CreateArtifactResponse;
class CreateArtifactResponseDefaultTypeInternal;
extern CreateArtifactResponseDefaultTypeInternal _CreateArtifactResponse_default_instance_;
class CreateTriggerRequest;
class CreateTriggerRequestDefaultTypeInternal;
extern CreateTriggerRequestDefaultTypeInternal _CreateTriggerRequest_default_instance_;
class CreateTriggerResponse;
class CreateTriggerResponseDefaultTypeInternal;
extern CreateTriggerResponseDefaultTypeInternal _CreateTriggerResponse_default_instance_;
class DeactivateTriggerRequest;
class DeactivateTriggerRequestDefaultTypeInternal;
extern DeactivateTriggerRequestDefaultTypeInternal _DeactivateTriggerRequest_default_instance_;
class DeactivateTriggerResponse;
class DeactivateTriggerResponseDefaultTypeInternal;
extern DeactivateTriggerResponseDefaultTypeInternal _DeactivateTriggerResponse_default_instance_;
class ExecutionInputsRequest;
class ExecutionInputsRequestDefaultTypeInternal;
extern ExecutionInputsRequestDefaultTypeInternal _ExecutionInputsRequest_default_instance_;
class ExecutionInputsResponse;
class ExecutionInputsResponseDefaultTypeInternal;
extern ExecutionInputsResponseDefaultTypeInternal _ExecutionInputsResponse_default_instance_;
class FindByWorkflowExecRequest;
class FindByWorkflowExecRequestDefaultTypeInternal;
extern FindByWorkflowExecRequestDefaultTypeInternal _FindByWorkflowExecRequest_default_instance_;
class GetArtifactRequest;
class GetArtifactRequestDefaultTypeInternal;
extern GetArtifactRequestDefaultTypeInternal _GetArtifactRequest_default_instance_;
class GetArtifactResponse;
class GetArtifactResponseDefaultTypeInternal;
extern GetArtifactResponseDefaultTypeInternal _GetArtifactResponse_default_instance_;
class RegisterConsumerRequest;
class RegisterConsumerRequestDefaultTypeInternal;
extern RegisterConsumerRequestDefaultTypeInternal _RegisterConsumerRequest_default_instance_;
class RegisterProducerRequest;
class RegisterProducerRequestDefaultTypeInternal;
extern RegisterProducerRequestDefaultTypeInternal _RegisterProducerRequest_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class SearchArtifactsRequest;
class SearchArtifactsRequestDefaultTypeInternal;
extern SearchArtifactsRequestDefaultTypeInternal _SearchArtifactsRequest_default_instance_;
class SearchArtifactsResponse;
class SearchArtifactsResponseDefaultTypeInternal;
extern SearchArtifactsResponseDefaultTypeInternal _SearchArtifactsResponse_default_instance_;
class SearchOptions;
class SearchOptionsDefaultTypeInternal;
extern SearchOptionsDefaultTypeInternal _SearchOptions_default_instance_;
}  // namespace artifact
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::artifact::AddTagRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::AddTagRequest>(Arena*);
template<> ::flyteidl::artifact::AddTagResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::AddTagResponse>(Arena*);
template<> ::flyteidl::artifact::Artifact* Arena::CreateMaybeMessage<::flyteidl::artifact::Artifact>(Arena*);
template<> ::flyteidl::artifact::ArtifactConsumer* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactConsumer>(Arena*);
template<> ::flyteidl::artifact::ArtifactProducer* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactProducer>(Arena*);
template<> ::flyteidl::artifact::ArtifactSource* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactSource>(Arena*);
template<> ::flyteidl::artifact::ArtifactSpec* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactSpec>(Arena*);
template<> ::flyteidl::artifact::CreateArtifactRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateArtifactRequest>(Arena*);
template<> ::flyteidl::artifact::CreateArtifactRequest_PartitionsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateArtifactRequest_PartitionsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::artifact::CreateArtifactResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateArtifactResponse>(Arena*);
template<> ::flyteidl::artifact::CreateTriggerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateTriggerRequest>(Arena*);
template<> ::flyteidl::artifact::CreateTriggerResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateTriggerResponse>(Arena*);
template<> ::flyteidl::artifact::DeactivateTriggerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::DeactivateTriggerRequest>(Arena*);
template<> ::flyteidl::artifact::DeactivateTriggerResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::DeactivateTriggerResponse>(Arena*);
template<> ::flyteidl::artifact::ExecutionInputsRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::ExecutionInputsRequest>(Arena*);
template<> ::flyteidl::artifact::ExecutionInputsResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::ExecutionInputsResponse>(Arena*);
template<> ::flyteidl::artifact::FindByWorkflowExecRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::FindByWorkflowExecRequest>(Arena*);
template<> ::flyteidl::artifact::GetArtifactRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::GetArtifactRequest>(Arena*);
template<> ::flyteidl::artifact::GetArtifactResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::GetArtifactResponse>(Arena*);
template<> ::flyteidl::artifact::RegisterConsumerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::RegisterConsumerRequest>(Arena*);
template<> ::flyteidl::artifact::RegisterProducerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::RegisterProducerRequest>(Arena*);
template<> ::flyteidl::artifact::RegisterResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::RegisterResponse>(Arena*);
template<> ::flyteidl::artifact::SearchArtifactsRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::SearchArtifactsRequest>(Arena*);
template<> ::flyteidl::artifact::SearchArtifactsResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::SearchArtifactsResponse>(Arena*);
template<> ::flyteidl::artifact::SearchOptions* Arena::CreateMaybeMessage<::flyteidl::artifact::SearchOptions>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace artifact {

enum FindByWorkflowExecRequest_Direction {
  FindByWorkflowExecRequest_Direction_INPUTS = 0,
  FindByWorkflowExecRequest_Direction_OUTPUTS = 1,
  FindByWorkflowExecRequest_Direction_FindByWorkflowExecRequest_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  FindByWorkflowExecRequest_Direction_FindByWorkflowExecRequest_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool FindByWorkflowExecRequest_Direction_IsValid(int value);
const FindByWorkflowExecRequest_Direction FindByWorkflowExecRequest_Direction_Direction_MIN = FindByWorkflowExecRequest_Direction_INPUTS;
const FindByWorkflowExecRequest_Direction FindByWorkflowExecRequest_Direction_Direction_MAX = FindByWorkflowExecRequest_Direction_OUTPUTS;
const int FindByWorkflowExecRequest_Direction_Direction_ARRAYSIZE = FindByWorkflowExecRequest_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* FindByWorkflowExecRequest_Direction_descriptor();
inline const ::std::string& FindByWorkflowExecRequest_Direction_Name(FindByWorkflowExecRequest_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    FindByWorkflowExecRequest_Direction_descriptor(), value);
}
inline bool FindByWorkflowExecRequest_Direction_Parse(
    const ::std::string& name, FindByWorkflowExecRequest_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FindByWorkflowExecRequest_Direction>(
    FindByWorkflowExecRequest_Direction_descriptor(), name, value);
}
// ===================================================================

class Artifact final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.Artifact) */ {
 public:
  Artifact();
  virtual ~Artifact();

  Artifact(const Artifact& from);

  inline Artifact& operator=(const Artifact& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Artifact(Artifact&& from) noexcept
    : Artifact() {
    *this = ::std::move(from);
  }

  inline Artifact& operator=(Artifact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Artifact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Artifact* internal_default_instance() {
    return reinterpret_cast<const Artifact*>(
               &_Artifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Artifact* other);
  friend void swap(Artifact& a, Artifact& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Artifact* New() const final {
    return CreateMaybeMessage<Artifact>(nullptr);
  }

  Artifact* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Artifact>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Artifact& from);
  void MergeFrom(const Artifact& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Artifact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 3;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 3;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_tags();

  // .flyteidl.core.ArtifactID artifact_id = 1;
  bool has_artifact_id() const;
  void clear_artifact_id();
  static const int kArtifactIdFieldNumber = 1;
  const ::flyteidl::core::ArtifactID& artifact_id() const;
  ::flyteidl::core::ArtifactID* release_artifact_id();
  ::flyteidl::core::ArtifactID* mutable_artifact_id();
  void set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id);

  // .flyteidl.artifact.ArtifactSpec spec = 2;
  bool has_spec() const;
  void clear_spec();
  static const int kSpecFieldNumber = 2;
  const ::flyteidl::artifact::ArtifactSpec& spec() const;
  ::flyteidl::artifact::ArtifactSpec* release_spec();
  ::flyteidl::artifact::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec);

  // .flyteidl.artifact.ArtifactSource source = 4;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 4;
  const ::flyteidl::artifact::ArtifactSource& source() const;
  ::flyteidl::artifact::ArtifactSource* release_source();
  ::flyteidl::artifact::ArtifactSource* mutable_source();
  void set_allocated_source(::flyteidl::artifact::ArtifactSource* source);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.Artifact)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> tags_;
  ::flyteidl::core::ArtifactID* artifact_id_;
  ::flyteidl::artifact::ArtifactSpec* spec_;
  ::flyteidl::artifact::ArtifactSource* source_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateArtifactRequest_PartitionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<CreateArtifactRequest_PartitionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<CreateArtifactRequest_PartitionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CreateArtifactRequest_PartitionsEntry_DoNotUse();
  CreateArtifactRequest_PartitionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const CreateArtifactRequest_PartitionsEntry_DoNotUse& other);
  static const CreateArtifactRequest_PartitionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateArtifactRequest_PartitionsEntry_DoNotUse*>(&_CreateArtifactRequest_PartitionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class CreateArtifactRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateArtifactRequest) */ {
 public:
  CreateArtifactRequest();
  virtual ~CreateArtifactRequest();

  CreateArtifactRequest(const CreateArtifactRequest& from);

  inline CreateArtifactRequest& operator=(const CreateArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateArtifactRequest(CreateArtifactRequest&& from) noexcept
    : CreateArtifactRequest() {
    *this = ::std::move(from);
  }

  inline CreateArtifactRequest& operator=(CreateArtifactRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateArtifactRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const CreateArtifactRequest*>(
               &_CreateArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CreateArtifactRequest* other);
  friend void swap(CreateArtifactRequest& a, CreateArtifactRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateArtifactRequest* New() const final {
    return CreateMaybeMessage<CreateArtifactRequest>(nullptr);
  }

  CreateArtifactRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateArtifactRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateArtifactRequest& from);
  void MergeFrom(const CreateArtifactRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateArtifactRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> partitions = 4;
  int partitions_size() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      partitions() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_partitions();

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string tag = 5;
  void clear_tag();
  static const int kTagFieldNumber = 5;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // .flyteidl.artifact.ArtifactSpec spec = 2;
  bool has_spec() const;
  void clear_spec();
  static const int kSpecFieldNumber = 2;
  const ::flyteidl::artifact::ArtifactSpec& spec() const;
  ::flyteidl::artifact::ArtifactSpec* release_spec();
  ::flyteidl::artifact::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec);

  // .flyteidl.artifact.ArtifactSource source = 6;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 6;
  const ::flyteidl::artifact::ArtifactSource& source() const;
  ::flyteidl::artifact::ArtifactSource* release_source();
  ::flyteidl::artifact::ArtifactSource* mutable_source();
  void set_allocated_source(::flyteidl::artifact::ArtifactSource* source);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateArtifactRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      CreateArtifactRequest_PartitionsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > partitions_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  ::flyteidl::artifact::ArtifactSpec* spec_;
  ::flyteidl::artifact::ArtifactSource* source_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactSource final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactSource) */ {
 public:
  ArtifactSource();
  virtual ~ArtifactSource();

  ArtifactSource(const ArtifactSource& from);

  inline ArtifactSource& operator=(const ArtifactSource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactSource(ArtifactSource&& from) noexcept
    : ArtifactSource() {
    *this = ::std::move(from);
  }

  inline ArtifactSource& operator=(ArtifactSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactSource* internal_default_instance() {
    return reinterpret_cast<const ArtifactSource*>(
               &_ArtifactSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ArtifactSource* other);
  friend void swap(ArtifactSource& a, ArtifactSource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactSource* New() const final {
    return CreateMaybeMessage<ArtifactSource>(nullptr);
  }

  ArtifactSource* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactSource>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactSource& from);
  void MergeFrom(const ArtifactSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_node_id(::std::string&& value);
  #endif
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // string principal = 5;
  void clear_principal();
  static const int kPrincipalFieldNumber = 5;
  const ::std::string& principal() const;
  void set_principal(const ::std::string& value);
  #if LANG_CXX11
  void set_principal(::std::string&& value);
  #endif
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  ::std::string* mutable_principal();
  ::std::string* release_principal();
  void set_allocated_principal(::std::string* principal);

  // .flyteidl.core.WorkflowExecutionIdentifier workflow_execution = 1;
  bool has_workflow_execution() const;
  void clear_workflow_execution();
  static const int kWorkflowExecutionFieldNumber = 1;
  const ::flyteidl::core::WorkflowExecutionIdentifier& workflow_execution() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* release_workflow_execution();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_workflow_execution();
  void set_allocated_workflow_execution(::flyteidl::core::WorkflowExecutionIdentifier* workflow_execution);

  // .flyteidl.core.Identifier task_id = 3;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  const ::flyteidl::core::Identifier& task_id() const;
  ::flyteidl::core::Identifier* release_task_id();
  ::flyteidl::core::Identifier* mutable_task_id();
  void set_allocated_task_id(::flyteidl::core::Identifier* task_id);

  // uint32 retry_attempt = 4;
  void clear_retry_attempt();
  static const int kRetryAttemptFieldNumber = 4;
  ::google::protobuf::uint32 retry_attempt() const;
  void set_retry_attempt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactSource)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::google::protobuf::internal::ArenaStringPtr principal_;
  ::flyteidl::core::WorkflowExecutionIdentifier* workflow_execution_;
  ::flyteidl::core::Identifier* task_id_;
  ::google::protobuf::uint32 retry_attempt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactSpec) */ {
 public:
  ArtifactSpec();
  virtual ~ArtifactSpec();

  ArtifactSpec(const ArtifactSpec& from);

  inline ArtifactSpec& operator=(const ArtifactSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactSpec(ArtifactSpec&& from) noexcept
    : ArtifactSpec() {
    *this = ::std::move(from);
  }

  inline ArtifactSpec& operator=(ArtifactSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactSpec* internal_default_instance() {
    return reinterpret_cast<const ArtifactSpec*>(
               &_ArtifactSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ArtifactSpec* other);
  friend void swap(ArtifactSpec& a, ArtifactSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactSpec* New() const final {
    return CreateMaybeMessage<ArtifactSpec>(nullptr);
  }

  ArtifactSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactSpec& from);
  void MergeFrom(const ArtifactSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string short_description = 3;
  void clear_short_description();
  static const int kShortDescriptionFieldNumber = 3;
  const ::std::string& short_description() const;
  void set_short_description(const ::std::string& value);
  #if LANG_CXX11
  void set_short_description(::std::string&& value);
  #endif
  void set_short_description(const char* value);
  void set_short_description(const char* value, size_t size);
  ::std::string* mutable_short_description();
  ::std::string* release_short_description();
  void set_allocated_short_description(::std::string* short_description);

  // string metadata_type = 5;
  void clear_metadata_type();
  static const int kMetadataTypeFieldNumber = 5;
  const ::std::string& metadata_type() const;
  void set_metadata_type(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata_type(::std::string&& value);
  #endif
  void set_metadata_type(const char* value);
  void set_metadata_type(const char* value, size_t size);
  ::std::string* mutable_metadata_type();
  ::std::string* release_metadata_type();
  void set_allocated_metadata_type(::std::string* metadata_type);

  // .flyteidl.core.Literal value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::flyteidl::core::Literal& value() const;
  ::flyteidl::core::Literal* release_value();
  ::flyteidl::core::Literal* mutable_value();
  void set_allocated_value(::flyteidl::core::Literal* value);

  // .flyteidl.core.LiteralType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::flyteidl::core::LiteralType& type() const;
  ::flyteidl::core::LiteralType* release_type();
  ::flyteidl::core::LiteralType* mutable_type();
  void set_allocated_type(::flyteidl::core::LiteralType* type);

  // .google.protobuf.Any user_metadata = 4;
  bool has_user_metadata() const;
  void clear_user_metadata();
  static const int kUserMetadataFieldNumber = 4;
  const ::google::protobuf::Any& user_metadata() const;
  ::google::protobuf::Any* release_user_metadata();
  ::google::protobuf::Any* mutable_user_metadata();
  void set_allocated_user_metadata(::google::protobuf::Any* user_metadata);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactSpec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr short_description_;
  ::google::protobuf::internal::ArenaStringPtr metadata_type_;
  ::flyteidl::core::Literal* value_;
  ::flyteidl::core::LiteralType* type_;
  ::google::protobuf::Any* user_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateArtifactResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateArtifactResponse) */ {
 public:
  CreateArtifactResponse();
  virtual ~CreateArtifactResponse();

  CreateArtifactResponse(const CreateArtifactResponse& from);

  inline CreateArtifactResponse& operator=(const CreateArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateArtifactResponse(CreateArtifactResponse&& from) noexcept
    : CreateArtifactResponse() {
    *this = ::std::move(from);
  }

  inline CreateArtifactResponse& operator=(CreateArtifactResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateArtifactResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const CreateArtifactResponse*>(
               &_CreateArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CreateArtifactResponse* other);
  friend void swap(CreateArtifactResponse& a, CreateArtifactResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateArtifactResponse* New() const final {
    return CreateMaybeMessage<CreateArtifactResponse>(nullptr);
  }

  CreateArtifactResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateArtifactResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateArtifactResponse& from);
  void MergeFrom(const CreateArtifactResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateArtifactResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.artifact.Artifact artifact = 1;
  bool has_artifact() const;
  void clear_artifact();
  static const int kArtifactFieldNumber = 1;
  const ::flyteidl::artifact::Artifact& artifact() const;
  ::flyteidl::artifact::Artifact* release_artifact();
  ::flyteidl::artifact::Artifact* mutable_artifact();
  void set_allocated_artifact(::flyteidl::artifact::Artifact* artifact);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateArtifactResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::artifact::Artifact* artifact_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.GetArtifactRequest) */ {
 public:
  GetArtifactRequest();
  virtual ~GetArtifactRequest();

  GetArtifactRequest(const GetArtifactRequest& from);

  inline GetArtifactRequest& operator=(const GetArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetArtifactRequest(GetArtifactRequest&& from) noexcept
    : GetArtifactRequest() {
    *this = ::std::move(from);
  }

  inline GetArtifactRequest& operator=(GetArtifactRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetArtifactRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const GetArtifactRequest*>(
               &_GetArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetArtifactRequest* other);
  friend void swap(GetArtifactRequest& a, GetArtifactRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetArtifactRequest* New() const final {
    return CreateMaybeMessage<GetArtifactRequest>(nullptr);
  }

  GetArtifactRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetArtifactRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetArtifactRequest& from);
  void MergeFrom(const GetArtifactRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.ArtifactQuery query = 1;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::flyteidl::core::ArtifactQuery& query() const;
  ::flyteidl::core::ArtifactQuery* release_query();
  ::flyteidl::core::ArtifactQuery* mutable_query();
  void set_allocated_query(::flyteidl::core::ArtifactQuery* query);

  // bool details = 2;
  void clear_details();
  static const int kDetailsFieldNumber = 2;
  bool details() const;
  void set_details(bool value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.GetArtifactRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::ArtifactQuery* query_;
  bool details_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.GetArtifactResponse) */ {
 public:
  GetArtifactResponse();
  virtual ~GetArtifactResponse();

  GetArtifactResponse(const GetArtifactResponse& from);

  inline GetArtifactResponse& operator=(const GetArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetArtifactResponse(GetArtifactResponse&& from) noexcept
    : GetArtifactResponse() {
    *this = ::std::move(from);
  }

  inline GetArtifactResponse& operator=(GetArtifactResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetArtifactResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const GetArtifactResponse*>(
               &_GetArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GetArtifactResponse* other);
  friend void swap(GetArtifactResponse& a, GetArtifactResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetArtifactResponse* New() const final {
    return CreateMaybeMessage<GetArtifactResponse>(nullptr);
  }

  GetArtifactResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetArtifactResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetArtifactResponse& from);
  void MergeFrom(const GetArtifactResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.artifact.Artifact artifact = 1;
  bool has_artifact() const;
  void clear_artifact();
  static const int kArtifactFieldNumber = 1;
  const ::flyteidl::artifact::Artifact& artifact() const;
  ::flyteidl::artifact::Artifact* release_artifact();
  ::flyteidl::artifact::Artifact* mutable_artifact();
  void set_allocated_artifact(::flyteidl::artifact::Artifact* artifact);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.GetArtifactResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::artifact::Artifact* artifact_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class SearchOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.SearchOptions) */ {
 public:
  SearchOptions();
  virtual ~SearchOptions();

  SearchOptions(const SearchOptions& from);

  inline SearchOptions& operator=(const SearchOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SearchOptions(SearchOptions&& from) noexcept
    : SearchOptions() {
    *this = ::std::move(from);
  }

  inline SearchOptions& operator=(SearchOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SearchOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchOptions* internal_default_instance() {
    return reinterpret_cast<const SearchOptions*>(
               &_SearchOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SearchOptions* other);
  friend void swap(SearchOptions& a, SearchOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SearchOptions* New() const final {
    return CreateMaybeMessage<SearchOptions>(nullptr);
  }

  SearchOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SearchOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SearchOptions& from);
  void MergeFrom(const SearchOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool strict_partitions = 1;
  void clear_strict_partitions();
  static const int kStrictPartitionsFieldNumber = 1;
  bool strict_partitions() const;
  void set_strict_partitions(bool value);

  // bool latest_by_key = 2;
  void clear_latest_by_key();
  static const int kLatestByKeyFieldNumber = 2;
  bool latest_by_key() const;
  void set_latest_by_key(bool value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.SearchOptions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool strict_partitions_;
  bool latest_by_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class SearchArtifactsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.SearchArtifactsRequest) */ {
 public:
  SearchArtifactsRequest();
  virtual ~SearchArtifactsRequest();

  SearchArtifactsRequest(const SearchArtifactsRequest& from);

  inline SearchArtifactsRequest& operator=(const SearchArtifactsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SearchArtifactsRequest(SearchArtifactsRequest&& from) noexcept
    : SearchArtifactsRequest() {
    *this = ::std::move(from);
  }

  inline SearchArtifactsRequest& operator=(SearchArtifactsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SearchArtifactsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchArtifactsRequest* internal_default_instance() {
    return reinterpret_cast<const SearchArtifactsRequest*>(
               &_SearchArtifactsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SearchArtifactsRequest* other);
  friend void swap(SearchArtifactsRequest& a, SearchArtifactsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SearchArtifactsRequest* New() const final {
    return CreateMaybeMessage<SearchArtifactsRequest>(nullptr);
  }

  SearchArtifactsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SearchArtifactsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SearchArtifactsRequest& from);
  void MergeFrom(const SearchArtifactsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchArtifactsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string principal = 3;
  void clear_principal();
  static const int kPrincipalFieldNumber = 3;
  const ::std::string& principal() const;
  void set_principal(const ::std::string& value);
  #if LANG_CXX11
  void set_principal(::std::string&& value);
  #endif
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  ::std::string* mutable_principal();
  ::std::string* release_principal();
  void set_allocated_principal(::std::string* principal);

  // string version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string token = 6;
  void clear_token();
  static const int kTokenFieldNumber = 6;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // .flyteidl.core.Partitions partitions = 2;
  bool has_partitions() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 2;
  const ::flyteidl::core::Partitions& partitions() const;
  ::flyteidl::core::Partitions* release_partitions();
  ::flyteidl::core::Partitions* mutable_partitions();
  void set_allocated_partitions(::flyteidl::core::Partitions* partitions);

  // .flyteidl.artifact.SearchOptions options = 5;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 5;
  const ::flyteidl::artifact::SearchOptions& options() const;
  ::flyteidl::artifact::SearchOptions* release_options();
  ::flyteidl::artifact::SearchOptions* mutable_options();
  void set_allocated_options(::flyteidl::artifact::SearchOptions* options);

  // int32 limit = 7;
  void clear_limit();
  static const int kLimitFieldNumber = 7;
  ::google::protobuf::int32 limit() const;
  void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.SearchArtifactsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr principal_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  ::flyteidl::core::Partitions* partitions_;
  ::flyteidl::artifact::SearchOptions* options_;
  ::google::protobuf::int32 limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class SearchArtifactsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.SearchArtifactsResponse) */ {
 public:
  SearchArtifactsResponse();
  virtual ~SearchArtifactsResponse();

  SearchArtifactsResponse(const SearchArtifactsResponse& from);

  inline SearchArtifactsResponse& operator=(const SearchArtifactsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SearchArtifactsResponse(SearchArtifactsResponse&& from) noexcept
    : SearchArtifactsResponse() {
    *this = ::std::move(from);
  }

  inline SearchArtifactsResponse& operator=(SearchArtifactsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SearchArtifactsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchArtifactsResponse* internal_default_instance() {
    return reinterpret_cast<const SearchArtifactsResponse*>(
               &_SearchArtifactsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SearchArtifactsResponse* other);
  friend void swap(SearchArtifactsResponse& a, SearchArtifactsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SearchArtifactsResponse* New() const final {
    return CreateMaybeMessage<SearchArtifactsResponse>(nullptr);
  }

  SearchArtifactsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SearchArtifactsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SearchArtifactsResponse& from);
  void MergeFrom(const SearchArtifactsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchArtifactsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.artifact.Artifact artifacts = 1;
  int artifacts_size() const;
  void clear_artifacts();
  static const int kArtifactsFieldNumber = 1;
  ::flyteidl::artifact::Artifact* mutable_artifacts(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >*
      mutable_artifacts();
  const ::flyteidl::artifact::Artifact& artifacts(int index) const;
  ::flyteidl::artifact::Artifact* add_artifacts();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >&
      artifacts() const;

  // string token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.SearchArtifactsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact > artifacts_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class FindByWorkflowExecRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.FindByWorkflowExecRequest) */ {
 public:
  FindByWorkflowExecRequest();
  virtual ~FindByWorkflowExecRequest();

  FindByWorkflowExecRequest(const FindByWorkflowExecRequest& from);

  inline FindByWorkflowExecRequest& operator=(const FindByWorkflowExecRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindByWorkflowExecRequest(FindByWorkflowExecRequest&& from) noexcept
    : FindByWorkflowExecRequest() {
    *this = ::std::move(from);
  }

  inline FindByWorkflowExecRequest& operator=(FindByWorkflowExecRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FindByWorkflowExecRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindByWorkflowExecRequest* internal_default_instance() {
    return reinterpret_cast<const FindByWorkflowExecRequest*>(
               &_FindByWorkflowExecRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FindByWorkflowExecRequest* other);
  friend void swap(FindByWorkflowExecRequest& a, FindByWorkflowExecRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindByWorkflowExecRequest* New() const final {
    return CreateMaybeMessage<FindByWorkflowExecRequest>(nullptr);
  }

  FindByWorkflowExecRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindByWorkflowExecRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindByWorkflowExecRequest& from);
  void MergeFrom(const FindByWorkflowExecRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindByWorkflowExecRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FindByWorkflowExecRequest_Direction Direction;
  static const Direction INPUTS =
    FindByWorkflowExecRequest_Direction_INPUTS;
  static const Direction OUTPUTS =
    FindByWorkflowExecRequest_Direction_OUTPUTS;
  static inline bool Direction_IsValid(int value) {
    return FindByWorkflowExecRequest_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    FindByWorkflowExecRequest_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    FindByWorkflowExecRequest_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    FindByWorkflowExecRequest_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return FindByWorkflowExecRequest_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return FindByWorkflowExecRequest_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return FindByWorkflowExecRequest_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .flyteidl.core.WorkflowExecutionIdentifier exec_id = 1;
  bool has_exec_id() const;
  void clear_exec_id();
  static const int kExecIdFieldNumber = 1;
  const ::flyteidl::core::WorkflowExecutionIdentifier& exec_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* release_exec_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_exec_id();
  void set_allocated_exec_id(::flyteidl::core::WorkflowExecutionIdentifier* exec_id);

  // .flyteidl.artifact.FindByWorkflowExecRequest.Direction direction = 2;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::flyteidl::artifact::FindByWorkflowExecRequest_Direction direction() const;
  void set_direction(::flyteidl::artifact::FindByWorkflowExecRequest_Direction value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.FindByWorkflowExecRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::WorkflowExecutionIdentifier* exec_id_;
  int direction_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class AddTagRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.AddTagRequest) */ {
 public:
  AddTagRequest();
  virtual ~AddTagRequest();

  AddTagRequest(const AddTagRequest& from);

  inline AddTagRequest& operator=(const AddTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTagRequest(AddTagRequest&& from) noexcept
    : AddTagRequest() {
    *this = ::std::move(from);
  }

  inline AddTagRequest& operator=(AddTagRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AddTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTagRequest* internal_default_instance() {
    return reinterpret_cast<const AddTagRequest*>(
               &_AddTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(AddTagRequest* other);
  friend void swap(AddTagRequest& a, AddTagRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTagRequest* New() const final {
    return CreateMaybeMessage<AddTagRequest>(nullptr);
  }

  AddTagRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTagRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTagRequest& from);
  void MergeFrom(const AddTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTagRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .flyteidl.core.ArtifactID artifact_id = 1;
  bool has_artifact_id() const;
  void clear_artifact_id();
  static const int kArtifactIdFieldNumber = 1;
  const ::flyteidl::core::ArtifactID& artifact_id() const;
  ::flyteidl::core::ArtifactID* release_artifact_id();
  ::flyteidl::core::ArtifactID* mutable_artifact_id();
  void set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id);

  // bool overwrite = 3;
  void clear_overwrite();
  static const int kOverwriteFieldNumber = 3;
  bool overwrite() const;
  void set_overwrite(bool value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.AddTagRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::flyteidl::core::ArtifactID* artifact_id_;
  bool overwrite_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class AddTagResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.AddTagResponse) */ {
 public:
  AddTagResponse();
  virtual ~AddTagResponse();

  AddTagResponse(const AddTagResponse& from);

  inline AddTagResponse& operator=(const AddTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTagResponse(AddTagResponse&& from) noexcept
    : AddTagResponse() {
    *this = ::std::move(from);
  }

  inline AddTagResponse& operator=(AddTagResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AddTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTagResponse* internal_default_instance() {
    return reinterpret_cast<const AddTagResponse*>(
               &_AddTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(AddTagResponse* other);
  friend void swap(AddTagResponse& a, AddTagResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTagResponse* New() const final {
    return CreateMaybeMessage<AddTagResponse>(nullptr);
  }

  AddTagResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTagResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTagResponse& from);
  void MergeFrom(const AddTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTagResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.AddTagResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateTriggerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateTriggerRequest) */ {
 public:
  CreateTriggerRequest();
  virtual ~CreateTriggerRequest();

  CreateTriggerRequest(const CreateTriggerRequest& from);

  inline CreateTriggerRequest& operator=(const CreateTriggerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTriggerRequest(CreateTriggerRequest&& from) noexcept
    : CreateTriggerRequest() {
    *this = ::std::move(from);
  }

  inline CreateTriggerRequest& operator=(CreateTriggerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateTriggerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTriggerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTriggerRequest*>(
               &_CreateTriggerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CreateTriggerRequest* other);
  friend void swap(CreateTriggerRequest& a, CreateTriggerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTriggerRequest* New() const final {
    return CreateMaybeMessage<CreateTriggerRequest>(nullptr);
  }

  CreateTriggerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateTriggerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateTriggerRequest& from);
  void MergeFrom(const CreateTriggerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTriggerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.admin.LaunchPlan trigger_launch_plan = 1;
  bool has_trigger_launch_plan() const;
  void clear_trigger_launch_plan();
  static const int kTriggerLaunchPlanFieldNumber = 1;
  const ::flyteidl::admin::LaunchPlan& trigger_launch_plan() const;
  ::flyteidl::admin::LaunchPlan* release_trigger_launch_plan();
  ::flyteidl::admin::LaunchPlan* mutable_trigger_launch_plan();
  void set_allocated_trigger_launch_plan(::flyteidl::admin::LaunchPlan* trigger_launch_plan);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateTriggerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::admin::LaunchPlan* trigger_launch_plan_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateTriggerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateTriggerResponse) */ {
 public:
  CreateTriggerResponse();
  virtual ~CreateTriggerResponse();

  CreateTriggerResponse(const CreateTriggerResponse& from);

  inline CreateTriggerResponse& operator=(const CreateTriggerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTriggerResponse(CreateTriggerResponse&& from) noexcept
    : CreateTriggerResponse() {
    *this = ::std::move(from);
  }

  inline CreateTriggerResponse& operator=(CreateTriggerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateTriggerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTriggerResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTriggerResponse*>(
               &_CreateTriggerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CreateTriggerResponse* other);
  friend void swap(CreateTriggerResponse& a, CreateTriggerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTriggerResponse* New() const final {
    return CreateMaybeMessage<CreateTriggerResponse>(nullptr);
  }

  CreateTriggerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateTriggerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateTriggerResponse& from);
  void MergeFrom(const CreateTriggerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTriggerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateTriggerResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class DeactivateTriggerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.DeactivateTriggerRequest) */ {
 public:
  DeactivateTriggerRequest();
  virtual ~DeactivateTriggerRequest();

  DeactivateTriggerRequest(const DeactivateTriggerRequest& from);

  inline DeactivateTriggerRequest& operator=(const DeactivateTriggerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeactivateTriggerRequest(DeactivateTriggerRequest&& from) noexcept
    : DeactivateTriggerRequest() {
    *this = ::std::move(from);
  }

  inline DeactivateTriggerRequest& operator=(DeactivateTriggerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeactivateTriggerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeactivateTriggerRequest* internal_default_instance() {
    return reinterpret_cast<const DeactivateTriggerRequest*>(
               &_DeactivateTriggerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(DeactivateTriggerRequest* other);
  friend void swap(DeactivateTriggerRequest& a, DeactivateTriggerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeactivateTriggerRequest* New() const final {
    return CreateMaybeMessage<DeactivateTriggerRequest>(nullptr);
  }

  DeactivateTriggerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeactivateTriggerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeactivateTriggerRequest& from);
  void MergeFrom(const DeactivateTriggerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeactivateTriggerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Identifier trigger_id = 1;
  bool has_trigger_id() const;
  void clear_trigger_id();
  static const int kTriggerIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& trigger_id() const;
  ::flyteidl::core::Identifier* release_trigger_id();
  ::flyteidl::core::Identifier* mutable_trigger_id();
  void set_allocated_trigger_id(::flyteidl::core::Identifier* trigger_id);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.DeactivateTriggerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::Identifier* trigger_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class DeactivateTriggerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.DeactivateTriggerResponse) */ {
 public:
  DeactivateTriggerResponse();
  virtual ~DeactivateTriggerResponse();

  DeactivateTriggerResponse(const DeactivateTriggerResponse& from);

  inline DeactivateTriggerResponse& operator=(const DeactivateTriggerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeactivateTriggerResponse(DeactivateTriggerResponse&& from) noexcept
    : DeactivateTriggerResponse() {
    *this = ::std::move(from);
  }

  inline DeactivateTriggerResponse& operator=(DeactivateTriggerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeactivateTriggerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeactivateTriggerResponse* internal_default_instance() {
    return reinterpret_cast<const DeactivateTriggerResponse*>(
               &_DeactivateTriggerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(DeactivateTriggerResponse* other);
  friend void swap(DeactivateTriggerResponse& a, DeactivateTriggerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeactivateTriggerResponse* New() const final {
    return CreateMaybeMessage<DeactivateTriggerResponse>(nullptr);
  }

  DeactivateTriggerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeactivateTriggerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeactivateTriggerResponse& from);
  void MergeFrom(const DeactivateTriggerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeactivateTriggerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.DeactivateTriggerResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactProducer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactProducer) */ {
 public:
  ArtifactProducer();
  virtual ~ArtifactProducer();

  ArtifactProducer(const ArtifactProducer& from);

  inline ArtifactProducer& operator=(const ArtifactProducer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactProducer(ArtifactProducer&& from) noexcept
    : ArtifactProducer() {
    *this = ::std::move(from);
  }

  inline ArtifactProducer& operator=(ArtifactProducer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactProducer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactProducer* internal_default_instance() {
    return reinterpret_cast<const ArtifactProducer*>(
               &_ArtifactProducer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ArtifactProducer* other);
  friend void swap(ArtifactProducer& a, ArtifactProducer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactProducer* New() const final {
    return CreateMaybeMessage<ArtifactProducer>(nullptr);
  }

  ArtifactProducer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactProducer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactProducer& from);
  void MergeFrom(const ArtifactProducer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactProducer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Identifier entity_id = 1;
  bool has_entity_id() const;
  void clear_entity_id();
  static const int kEntityIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& entity_id() const;
  ::flyteidl::core::Identifier* release_entity_id();
  ::flyteidl::core::Identifier* mutable_entity_id();
  void set_allocated_entity_id(::flyteidl::core::Identifier* entity_id);

  // .flyteidl.core.VariableMap outputs = 2;
  bool has_outputs() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::flyteidl::core::VariableMap& outputs() const;
  ::flyteidl::core::VariableMap* release_outputs();
  ::flyteidl::core::VariableMap* mutable_outputs();
  void set_allocated_outputs(::flyteidl::core::VariableMap* outputs);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactProducer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::Identifier* entity_id_;
  ::flyteidl::core::VariableMap* outputs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class RegisterProducerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.RegisterProducerRequest) */ {
 public:
  RegisterProducerRequest();
  virtual ~RegisterProducerRequest();

  RegisterProducerRequest(const RegisterProducerRequest& from);

  inline RegisterProducerRequest& operator=(const RegisterProducerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterProducerRequest(RegisterProducerRequest&& from) noexcept
    : RegisterProducerRequest() {
    *this = ::std::move(from);
  }

  inline RegisterProducerRequest& operator=(RegisterProducerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterProducerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterProducerRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterProducerRequest*>(
               &_RegisterProducerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(RegisterProducerRequest* other);
  friend void swap(RegisterProducerRequest& a, RegisterProducerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterProducerRequest* New() const final {
    return CreateMaybeMessage<RegisterProducerRequest>(nullptr);
  }

  RegisterProducerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterProducerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterProducerRequest& from);
  void MergeFrom(const RegisterProducerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterProducerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.artifact.ArtifactProducer producers = 1;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 1;
  ::flyteidl::artifact::ArtifactProducer* mutable_producers(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >*
      mutable_producers();
  const ::flyteidl::artifact::ArtifactProducer& producers(int index) const;
  ::flyteidl::artifact::ArtifactProducer* add_producers();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >&
      producers() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.RegisterProducerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer > producers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactConsumer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactConsumer) */ {
 public:
  ArtifactConsumer();
  virtual ~ArtifactConsumer();

  ArtifactConsumer(const ArtifactConsumer& from);

  inline ArtifactConsumer& operator=(const ArtifactConsumer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactConsumer(ArtifactConsumer&& from) noexcept
    : ArtifactConsumer() {
    *this = ::std::move(from);
  }

  inline ArtifactConsumer& operator=(ArtifactConsumer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactConsumer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactConsumer* internal_default_instance() {
    return reinterpret_cast<const ArtifactConsumer*>(
               &_ArtifactConsumer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ArtifactConsumer* other);
  friend void swap(ArtifactConsumer& a, ArtifactConsumer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactConsumer* New() const final {
    return CreateMaybeMessage<ArtifactConsumer>(nullptr);
  }

  ArtifactConsumer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactConsumer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactConsumer& from);
  void MergeFrom(const ArtifactConsumer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactConsumer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Identifier entity_id = 1;
  bool has_entity_id() const;
  void clear_entity_id();
  static const int kEntityIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& entity_id() const;
  ::flyteidl::core::Identifier* release_entity_id();
  ::flyteidl::core::Identifier* mutable_entity_id();
  void set_allocated_entity_id(::flyteidl::core::Identifier* entity_id);

  // .flyteidl.core.ParameterMap inputs = 2;
  bool has_inputs() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  const ::flyteidl::core::ParameterMap& inputs() const;
  ::flyteidl::core::ParameterMap* release_inputs();
  ::flyteidl::core::ParameterMap* mutable_inputs();
  void set_allocated_inputs(::flyteidl::core::ParameterMap* inputs);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactConsumer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::Identifier* entity_id_;
  ::flyteidl::core::ParameterMap* inputs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class RegisterConsumerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.RegisterConsumerRequest) */ {
 public:
  RegisterConsumerRequest();
  virtual ~RegisterConsumerRequest();

  RegisterConsumerRequest(const RegisterConsumerRequest& from);

  inline RegisterConsumerRequest& operator=(const RegisterConsumerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterConsumerRequest(RegisterConsumerRequest&& from) noexcept
    : RegisterConsumerRequest() {
    *this = ::std::move(from);
  }

  inline RegisterConsumerRequest& operator=(RegisterConsumerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterConsumerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterConsumerRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterConsumerRequest*>(
               &_RegisterConsumerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(RegisterConsumerRequest* other);
  friend void swap(RegisterConsumerRequest& a, RegisterConsumerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterConsumerRequest* New() const final {
    return CreateMaybeMessage<RegisterConsumerRequest>(nullptr);
  }

  RegisterConsumerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterConsumerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterConsumerRequest& from);
  void MergeFrom(const RegisterConsumerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterConsumerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.artifact.ArtifactConsumer consumers = 1;
  int consumers_size() const;
  void clear_consumers();
  static const int kConsumersFieldNumber = 1;
  ::flyteidl::artifact::ArtifactConsumer* mutable_consumers(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >*
      mutable_consumers();
  const ::flyteidl::artifact::ArtifactConsumer& consumers(int index) const;
  ::flyteidl::artifact::ArtifactConsumer* add_consumers();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >&
      consumers() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.RegisterConsumerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer > consumers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(RegisterResponse* other);
  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterResponse>(nullptr);
  }

  RegisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.RegisterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ExecutionInputsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ExecutionInputsRequest) */ {
 public:
  ExecutionInputsRequest();
  virtual ~ExecutionInputsRequest();

  ExecutionInputsRequest(const ExecutionInputsRequest& from);

  inline ExecutionInputsRequest& operator=(const ExecutionInputsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecutionInputsRequest(ExecutionInputsRequest&& from) noexcept
    : ExecutionInputsRequest() {
    *this = ::std::move(from);
  }

  inline ExecutionInputsRequest& operator=(ExecutionInputsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ExecutionInputsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecutionInputsRequest* internal_default_instance() {
    return reinterpret_cast<const ExecutionInputsRequest*>(
               &_ExecutionInputsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ExecutionInputsRequest* other);
  friend void swap(ExecutionInputsRequest& a, ExecutionInputsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecutionInputsRequest* New() const final {
    return CreateMaybeMessage<ExecutionInputsRequest>(nullptr);
  }

  ExecutionInputsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecutionInputsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecutionInputsRequest& from);
  void MergeFrom(const ExecutionInputsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionInputsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.ArtifactID inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  ::flyteidl::core::ArtifactID* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID >*
      mutable_inputs();
  const ::flyteidl::core::ArtifactID& inputs(int index) const;
  ::flyteidl::core::ArtifactID* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID >&
      inputs() const;

  // .flyteidl.core.WorkflowExecutionIdentifier execution_id = 1;
  bool has_execution_id() const;
  void clear_execution_id();
  static const int kExecutionIdFieldNumber = 1;
  const ::flyteidl::core::WorkflowExecutionIdentifier& execution_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* release_execution_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_execution_id();
  void set_allocated_execution_id(::flyteidl::core::WorkflowExecutionIdentifier* execution_id);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ExecutionInputsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID > inputs_;
  ::flyteidl::core::WorkflowExecutionIdentifier* execution_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ExecutionInputsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ExecutionInputsResponse) */ {
 public:
  ExecutionInputsResponse();
  virtual ~ExecutionInputsResponse();

  ExecutionInputsResponse(const ExecutionInputsResponse& from);

  inline ExecutionInputsResponse& operator=(const ExecutionInputsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecutionInputsResponse(ExecutionInputsResponse&& from) noexcept
    : ExecutionInputsResponse() {
    *this = ::std::move(from);
  }

  inline ExecutionInputsResponse& operator=(ExecutionInputsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ExecutionInputsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecutionInputsResponse* internal_default_instance() {
    return reinterpret_cast<const ExecutionInputsResponse*>(
               &_ExecutionInputsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ExecutionInputsResponse* other);
  friend void swap(ExecutionInputsResponse& a, ExecutionInputsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecutionInputsResponse* New() const final {
    return CreateMaybeMessage<ExecutionInputsResponse>(nullptr);
  }

  ExecutionInputsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecutionInputsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecutionInputsResponse& from);
  void MergeFrom(const ExecutionInputsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionInputsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ExecutionInputsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Artifact

// .flyteidl.core.ArtifactID artifact_id = 1;
inline bool Artifact::has_artifact_id() const {
  return this != internal_default_instance() && artifact_id_ != nullptr;
}
inline const ::flyteidl::core::ArtifactID& Artifact::artifact_id() const {
  const ::flyteidl::core::ArtifactID* p = artifact_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.artifact_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactID*>(
      &::flyteidl::core::_ArtifactID_default_instance_);
}
inline ::flyteidl::core::ArtifactID* Artifact::release_artifact_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.Artifact.artifact_id)
  
  ::flyteidl::core::ArtifactID* temp = artifact_id_;
  artifact_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactID* Artifact::mutable_artifact_id() {
  
  if (artifact_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactID>(GetArenaNoVirtual());
    artifact_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.artifact_id)
  return artifact_id_;
}
inline void Artifact::set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_id_);
  }
  if (artifact_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_id, submessage_arena);
    }
    
  } else {
    
  }
  artifact_id_ = artifact_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.Artifact.artifact_id)
}

// .flyteidl.artifact.ArtifactSpec spec = 2;
inline bool Artifact::has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline void Artifact::clear_spec() {
  if (GetArenaNoVirtual() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::flyteidl::artifact::ArtifactSpec& Artifact::spec() const {
  const ::flyteidl::artifact::ArtifactSpec* p = spec_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::ArtifactSpec*>(
      &::flyteidl::artifact::_ArtifactSpec_default_instance_);
}
inline ::flyteidl::artifact::ArtifactSpec* Artifact::release_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.Artifact.spec)
  
  ::flyteidl::artifact::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::ArtifactSpec* Artifact::mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::ArtifactSpec>(GetArenaNoVirtual());
    spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.spec)
  return spec_;
}
inline void Artifact::set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.Artifact.spec)
}

// repeated string tags = 3;
inline int Artifact::tags_size() const {
  return tags_.size();
}
inline void Artifact::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Artifact::tags(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.tags)
  return tags_.Get(index);
}
inline ::std::string* Artifact::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.tags)
  return tags_.Mutable(index);
}
inline void Artifact::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.artifact.Artifact.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Artifact::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.artifact.Artifact.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Artifact::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.Artifact.tags)
}
inline void Artifact::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.Artifact.tags)
}
inline ::std::string* Artifact::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:flyteidl.artifact.Artifact.tags)
  return tags_.Add();
}
inline void Artifact::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.artifact.Artifact.tags)
}
#if LANG_CXX11
inline void Artifact::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.artifact.Artifact.tags)
}
#endif
inline void Artifact::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.artifact.Artifact.tags)
}
inline void Artifact::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.artifact.Artifact.tags)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Artifact::tags() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.Artifact.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Artifact::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.Artifact.tags)
  return &tags_;
}

// .flyteidl.artifact.ArtifactSource source = 4;
inline bool Artifact::has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline void Artifact::clear_source() {
  if (GetArenaNoVirtual() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::flyteidl::artifact::ArtifactSource& Artifact::source() const {
  const ::flyteidl::artifact::ArtifactSource* p = source_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.source)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::ArtifactSource*>(
      &::flyteidl::artifact::_ArtifactSource_default_instance_);
}
inline ::flyteidl::artifact::ArtifactSource* Artifact::release_source() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.Artifact.source)
  
  ::flyteidl::artifact::ArtifactSource* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::ArtifactSource* Artifact::mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::ArtifactSource>(GetArenaNoVirtual());
    source_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.source)
  return source_;
}
inline void Artifact::set_allocated_source(::flyteidl::artifact::ArtifactSource* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.Artifact.source)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateArtifactRequest

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool CreateArtifactRequest::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline const ::flyteidl::core::ArtifactKey& CreateArtifactRequest::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* CreateArtifactRequest::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* CreateArtifactRequest::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.artifact_key)
  return artifact_key_;
}
inline void CreateArtifactRequest::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_key_);
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.artifact_key)
}

// string version = 3;
inline void CreateArtifactRequest::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateArtifactRequest::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.version)
  return version_.GetNoArena();
}
inline void CreateArtifactRequest::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.CreateArtifactRequest.version)
}
#if LANG_CXX11
inline void CreateArtifactRequest::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.CreateArtifactRequest.version)
}
#endif
inline void CreateArtifactRequest::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.CreateArtifactRequest.version)
}
inline void CreateArtifactRequest::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.CreateArtifactRequest.version)
}
inline ::std::string* CreateArtifactRequest::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateArtifactRequest::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateArtifactRequest::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.version)
}

// .flyteidl.artifact.ArtifactSpec spec = 2;
inline bool CreateArtifactRequest::has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline void CreateArtifactRequest::clear_spec() {
  if (GetArenaNoVirtual() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::flyteidl::artifact::ArtifactSpec& CreateArtifactRequest::spec() const {
  const ::flyteidl::artifact::ArtifactSpec* p = spec_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::ArtifactSpec*>(
      &::flyteidl::artifact::_ArtifactSpec_default_instance_);
}
inline ::flyteidl::artifact::ArtifactSpec* CreateArtifactRequest::release_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.spec)
  
  ::flyteidl::artifact::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::ArtifactSpec* CreateArtifactRequest::mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::ArtifactSpec>(GetArenaNoVirtual());
    spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.spec)
  return spec_;
}
inline void CreateArtifactRequest::set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.spec)
}

// map<string, string> partitions = 4;
inline int CreateArtifactRequest::partitions_size() const {
  return partitions_.size();
}
inline void CreateArtifactRequest::clear_partitions() {
  partitions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
CreateArtifactRequest::partitions() const {
  // @@protoc_insertion_point(field_map:flyteidl.artifact.CreateArtifactRequest.partitions)
  return partitions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
CreateArtifactRequest::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.artifact.CreateArtifactRequest.partitions)
  return partitions_.MutableMap();
}

// string tag = 5;
inline void CreateArtifactRequest::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateArtifactRequest::tag() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.tag)
  return tag_.GetNoArena();
}
inline void CreateArtifactRequest::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.CreateArtifactRequest.tag)
}
#if LANG_CXX11
inline void CreateArtifactRequest::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.CreateArtifactRequest.tag)
}
#endif
inline void CreateArtifactRequest::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.CreateArtifactRequest.tag)
}
inline void CreateArtifactRequest::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.CreateArtifactRequest.tag)
}
inline ::std::string* CreateArtifactRequest::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateArtifactRequest::release_tag() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateArtifactRequest::set_allocated_tag(::std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.tag)
}

// .flyteidl.artifact.ArtifactSource source = 6;
inline bool CreateArtifactRequest::has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline void CreateArtifactRequest::clear_source() {
  if (GetArenaNoVirtual() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::flyteidl::artifact::ArtifactSource& CreateArtifactRequest::source() const {
  const ::flyteidl::artifact::ArtifactSource* p = source_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.source)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::ArtifactSource*>(
      &::flyteidl::artifact::_ArtifactSource_default_instance_);
}
inline ::flyteidl::artifact::ArtifactSource* CreateArtifactRequest::release_source() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.source)
  
  ::flyteidl::artifact::ArtifactSource* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::ArtifactSource* CreateArtifactRequest::mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::ArtifactSource>(GetArenaNoVirtual());
    source_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.source)
  return source_;
}
inline void CreateArtifactRequest::set_allocated_source(::flyteidl::artifact::ArtifactSource* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.source)
}

// -------------------------------------------------------------------

// ArtifactSource

// .flyteidl.core.WorkflowExecutionIdentifier workflow_execution = 1;
inline bool ArtifactSource::has_workflow_execution() const {
  return this != internal_default_instance() && workflow_execution_ != nullptr;
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ArtifactSource::workflow_execution() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = workflow_execution_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSource.workflow_execution)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier*>(
      &::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ArtifactSource::release_workflow_execution() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSource.workflow_execution)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = workflow_execution_;
  workflow_execution_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ArtifactSource::mutable_workflow_execution() {
  
  if (workflow_execution_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaNoVirtual());
    workflow_execution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSource.workflow_execution)
  return workflow_execution_;
}
inline void ArtifactSource::set_allocated_workflow_execution(::flyteidl::core::WorkflowExecutionIdentifier* workflow_execution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(workflow_execution_);
  }
  if (workflow_execution) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      workflow_execution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, workflow_execution, submessage_arena);
    }
    
  } else {
    
  }
  workflow_execution_ = workflow_execution;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSource.workflow_execution)
}

// string node_id = 2;
inline void ArtifactSource::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactSource::node_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSource.node_id)
  return node_id_.GetNoArena();
}
inline void ArtifactSource::set_node_id(const ::std::string& value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSource.node_id)
}
#if LANG_CXX11
inline void ArtifactSource::set_node_id(::std::string&& value) {
  
  node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSource.node_id)
}
#endif
inline void ArtifactSource::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSource.node_id)
}
inline void ArtifactSource::set_node_id(const char* value, size_t size) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSource.node_id)
}
inline ::std::string* ArtifactSource::mutable_node_id() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSource.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSource::release_node_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSource.node_id)
  
  return node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactSource::set_allocated_node_id(::std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSource.node_id)
}

// .flyteidl.core.Identifier task_id = 3;
inline bool ArtifactSource::has_task_id() const {
  return this != internal_default_instance() && task_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& ArtifactSource::task_id() const {
  const ::flyteidl::core::Identifier* p = task_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSource.task_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* ArtifactSource::release_task_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSource.task_id)
  
  ::flyteidl::core::Identifier* temp = task_id_;
  task_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ArtifactSource::mutable_task_id() {
  
  if (task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    task_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSource.task_id)
  return task_id_;
}
inline void ArtifactSource::set_allocated_task_id(::flyteidl::core::Identifier* task_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_id_);
  }
  if (task_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      task_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSource.task_id)
}

// uint32 retry_attempt = 4;
inline void ArtifactSource::clear_retry_attempt() {
  retry_attempt_ = 0u;
}
inline ::google::protobuf::uint32 ArtifactSource::retry_attempt() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSource.retry_attempt)
  return retry_attempt_;
}
inline void ArtifactSource::set_retry_attempt(::google::protobuf::uint32 value) {
  
  retry_attempt_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSource.retry_attempt)
}

// string principal = 5;
inline void ArtifactSource::clear_principal() {
  principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactSource::principal() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSource.principal)
  return principal_.GetNoArena();
}
inline void ArtifactSource::set_principal(const ::std::string& value) {
  
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSource.principal)
}
#if LANG_CXX11
inline void ArtifactSource::set_principal(::std::string&& value) {
  
  principal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSource.principal)
}
#endif
inline void ArtifactSource::set_principal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSource.principal)
}
inline void ArtifactSource::set_principal(const char* value, size_t size) {
  
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSource.principal)
}
inline ::std::string* ArtifactSource::mutable_principal() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSource.principal)
  return principal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSource::release_principal() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSource.principal)
  
  return principal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactSource::set_allocated_principal(::std::string* principal) {
  if (principal != nullptr) {
    
  } else {
    
  }
  principal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSource.principal)
}

// -------------------------------------------------------------------

// ArtifactSpec

// .flyteidl.core.Literal value = 1;
inline bool ArtifactSpec::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::flyteidl::core::Literal& ArtifactSpec::value() const {
  const ::flyteidl::core::Literal* p = value_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Literal*>(
      &::flyteidl::core::_Literal_default_instance_);
}
inline ::flyteidl::core::Literal* ArtifactSpec::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.value)
  
  ::flyteidl::core::Literal* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Literal* ArtifactSpec::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Literal>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.value)
  return value_;
}
inline void ArtifactSpec::set_allocated_value(::flyteidl::core::Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.value)
}

// .flyteidl.core.LiteralType type = 2;
inline bool ArtifactSpec::has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline const ::flyteidl::core::LiteralType& ArtifactSpec::type() const {
  const ::flyteidl::core::LiteralType* p = type_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::LiteralType*>(
      &::flyteidl::core::_LiteralType_default_instance_);
}
inline ::flyteidl::core::LiteralType* ArtifactSpec::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.type)
  
  ::flyteidl::core::LiteralType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralType* ArtifactSpec::mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.type)
  return type_;
}
inline void ArtifactSpec::set_allocated_type(::flyteidl::core::LiteralType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.type)
}

// string short_description = 3;
inline void ArtifactSpec::clear_short_description() {
  short_description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactSpec::short_description() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.short_description)
  return short_description_.GetNoArena();
}
inline void ArtifactSpec::set_short_description(const ::std::string& value) {
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.short_description)
}
#if LANG_CXX11
inline void ArtifactSpec::set_short_description(::std::string&& value) {
  
  short_description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSpec.short_description)
}
#endif
inline void ArtifactSpec::set_short_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSpec.short_description)
}
inline void ArtifactSpec::set_short_description(const char* value, size_t size) {
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSpec.short_description)
}
inline ::std::string* ArtifactSpec::mutable_short_description() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.short_description)
  return short_description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSpec::release_short_description() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.short_description)
  
  return short_description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactSpec::set_allocated_short_description(::std::string* short_description) {
  if (short_description != nullptr) {
    
  } else {
    
  }
  short_description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), short_description);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.short_description)
}

// .google.protobuf.Any user_metadata = 4;
inline bool ArtifactSpec::has_user_metadata() const {
  return this != internal_default_instance() && user_metadata_ != nullptr;
}
inline const ::google::protobuf::Any& ArtifactSpec::user_metadata() const {
  const ::google::protobuf::Any* p = user_metadata_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.user_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ArtifactSpec::release_user_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.user_metadata)
  
  ::google::protobuf::Any* temp = user_metadata_;
  user_metadata_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ArtifactSpec::mutable_user_metadata() {
  
  if (user_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    user_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.user_metadata)
  return user_metadata_;
}
inline void ArtifactSpec::set_allocated_user_metadata(::google::protobuf::Any* user_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_metadata_);
  }
  if (user_metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_metadata, submessage_arena);
    }
    
  } else {
    
  }
  user_metadata_ = user_metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.user_metadata)
}

// string metadata_type = 5;
inline void ArtifactSpec::clear_metadata_type() {
  metadata_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactSpec::metadata_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.metadata_type)
  return metadata_type_.GetNoArena();
}
inline void ArtifactSpec::set_metadata_type(const ::std::string& value) {
  
  metadata_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.metadata_type)
}
#if LANG_CXX11
inline void ArtifactSpec::set_metadata_type(::std::string&& value) {
  
  metadata_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSpec.metadata_type)
}
#endif
inline void ArtifactSpec::set_metadata_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  metadata_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSpec.metadata_type)
}
inline void ArtifactSpec::set_metadata_type(const char* value, size_t size) {
  
  metadata_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSpec.metadata_type)
}
inline ::std::string* ArtifactSpec::mutable_metadata_type() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.metadata_type)
  return metadata_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSpec::release_metadata_type() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.metadata_type)
  
  return metadata_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactSpec::set_allocated_metadata_type(::std::string* metadata_type) {
  if (metadata_type != nullptr) {
    
  } else {
    
  }
  metadata_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata_type);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.metadata_type)
}

// -------------------------------------------------------------------

// CreateArtifactResponse

// .flyteidl.artifact.Artifact artifact = 1;
inline bool CreateArtifactResponse::has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline void CreateArtifactResponse::clear_artifact() {
  if (GetArenaNoVirtual() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::flyteidl::artifact::Artifact& CreateArtifactResponse::artifact() const {
  const ::flyteidl::artifact::Artifact* p = artifact_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactResponse.artifact)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::Artifact*>(
      &::flyteidl::artifact::_Artifact_default_instance_);
}
inline ::flyteidl::artifact::Artifact* CreateArtifactResponse::release_artifact() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactResponse.artifact)
  
  ::flyteidl::artifact::Artifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::Artifact* CreateArtifactResponse::mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::Artifact>(GetArenaNoVirtual());
    artifact_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactResponse.artifact)
  return artifact_;
}
inline void CreateArtifactResponse::set_allocated_artifact(::flyteidl::artifact::Artifact* artifact) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactResponse.artifact)
}

// -------------------------------------------------------------------

// GetArtifactRequest

// .flyteidl.core.ArtifactQuery query = 1;
inline bool GetArtifactRequest::has_query() const {
  return this != internal_default_instance() && query_ != nullptr;
}
inline const ::flyteidl::core::ArtifactQuery& GetArtifactRequest::query() const {
  const ::flyteidl::core::ArtifactQuery* p = query_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.GetArtifactRequest.query)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactQuery*>(
      &::flyteidl::core::_ArtifactQuery_default_instance_);
}
inline ::flyteidl::core::ArtifactQuery* GetArtifactRequest::release_query() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.GetArtifactRequest.query)
  
  ::flyteidl::core::ArtifactQuery* temp = query_;
  query_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactQuery* GetArtifactRequest::mutable_query() {
  
  if (query_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactQuery>(GetArenaNoVirtual());
    query_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.GetArtifactRequest.query)
  return query_;
}
inline void GetArtifactRequest::set_allocated_query(::flyteidl::core::ArtifactQuery* query) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(query_);
  }
  if (query) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  query_ = query;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.GetArtifactRequest.query)
}

// bool details = 2;
inline void GetArtifactRequest::clear_details() {
  details_ = false;
}
inline bool GetArtifactRequest::details() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.GetArtifactRequest.details)
  return details_;
}
inline void GetArtifactRequest::set_details(bool value) {
  
  details_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.GetArtifactRequest.details)
}

// -------------------------------------------------------------------

// GetArtifactResponse

// .flyteidl.artifact.Artifact artifact = 1;
inline bool GetArtifactResponse::has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline void GetArtifactResponse::clear_artifact() {
  if (GetArenaNoVirtual() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::flyteidl::artifact::Artifact& GetArtifactResponse::artifact() const {
  const ::flyteidl::artifact::Artifact* p = artifact_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.GetArtifactResponse.artifact)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::Artifact*>(
      &::flyteidl::artifact::_Artifact_default_instance_);
}
inline ::flyteidl::artifact::Artifact* GetArtifactResponse::release_artifact() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.GetArtifactResponse.artifact)
  
  ::flyteidl::artifact::Artifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::Artifact* GetArtifactResponse::mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::Artifact>(GetArenaNoVirtual());
    artifact_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.GetArtifactResponse.artifact)
  return artifact_;
}
inline void GetArtifactResponse::set_allocated_artifact(::flyteidl::artifact::Artifact* artifact) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.GetArtifactResponse.artifact)
}

// -------------------------------------------------------------------

// SearchOptions

// bool strict_partitions = 1;
inline void SearchOptions::clear_strict_partitions() {
  strict_partitions_ = false;
}
inline bool SearchOptions::strict_partitions() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchOptions.strict_partitions)
  return strict_partitions_;
}
inline void SearchOptions::set_strict_partitions(bool value) {
  
  strict_partitions_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchOptions.strict_partitions)
}

// bool latest_by_key = 2;
inline void SearchOptions::clear_latest_by_key() {
  latest_by_key_ = false;
}
inline bool SearchOptions::latest_by_key() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchOptions.latest_by_key)
  return latest_by_key_;
}
inline void SearchOptions::set_latest_by_key(bool value) {
  
  latest_by_key_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchOptions.latest_by_key)
}

// -------------------------------------------------------------------

// SearchArtifactsRequest

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool SearchArtifactsRequest::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline const ::flyteidl::core::ArtifactKey& SearchArtifactsRequest::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* SearchArtifactsRequest::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsRequest.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* SearchArtifactsRequest::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsRequest.artifact_key)
  return artifact_key_;
}
inline void SearchArtifactsRequest::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_key_);
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsRequest.artifact_key)
}

// .flyteidl.core.Partitions partitions = 2;
inline bool SearchArtifactsRequest::has_partitions() const {
  return this != internal_default_instance() && partitions_ != nullptr;
}
inline const ::flyteidl::core::Partitions& SearchArtifactsRequest::partitions() const {
  const ::flyteidl::core::Partitions* p = partitions_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.partitions)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Partitions*>(
      &::flyteidl::core::_Partitions_default_instance_);
}
inline ::flyteidl::core::Partitions* SearchArtifactsRequest::release_partitions() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsRequest.partitions)
  
  ::flyteidl::core::Partitions* temp = partitions_;
  partitions_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Partitions* SearchArtifactsRequest::mutable_partitions() {
  
  if (partitions_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Partitions>(GetArenaNoVirtual());
    partitions_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsRequest.partitions)
  return partitions_;
}
inline void SearchArtifactsRequest::set_allocated_partitions(::flyteidl::core::Partitions* partitions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(partitions_);
  }
  if (partitions) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      partitions = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, partitions, submessage_arena);
    }
    
  } else {
    
  }
  partitions_ = partitions;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsRequest.partitions)
}

// string principal = 3;
inline void SearchArtifactsRequest::clear_principal() {
  principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SearchArtifactsRequest::principal() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.principal)
  return principal_.GetNoArena();
}
inline void SearchArtifactsRequest::set_principal(const ::std::string& value) {
  
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchArtifactsRequest.principal)
}
#if LANG_CXX11
inline void SearchArtifactsRequest::set_principal(::std::string&& value) {
  
  principal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.SearchArtifactsRequest.principal)
}
#endif
inline void SearchArtifactsRequest::set_principal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.SearchArtifactsRequest.principal)
}
inline void SearchArtifactsRequest::set_principal(const char* value, size_t size) {
  
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.SearchArtifactsRequest.principal)
}
inline ::std::string* SearchArtifactsRequest::mutable_principal() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsRequest.principal)
  return principal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchArtifactsRequest::release_principal() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsRequest.principal)
  
  return principal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchArtifactsRequest::set_allocated_principal(::std::string* principal) {
  if (principal != nullptr) {
    
  } else {
    
  }
  principal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsRequest.principal)
}

// string version = 4;
inline void SearchArtifactsRequest::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SearchArtifactsRequest::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.version)
  return version_.GetNoArena();
}
inline void SearchArtifactsRequest::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchArtifactsRequest.version)
}
#if LANG_CXX11
inline void SearchArtifactsRequest::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.SearchArtifactsRequest.version)
}
#endif
inline void SearchArtifactsRequest::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.SearchArtifactsRequest.version)
}
inline void SearchArtifactsRequest::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.SearchArtifactsRequest.version)
}
inline ::std::string* SearchArtifactsRequest::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsRequest.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchArtifactsRequest::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsRequest.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchArtifactsRequest::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsRequest.version)
}

// .flyteidl.artifact.SearchOptions options = 5;
inline bool SearchArtifactsRequest::has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline void SearchArtifactsRequest::clear_options() {
  if (GetArenaNoVirtual() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::flyteidl::artifact::SearchOptions& SearchArtifactsRequest::options() const {
  const ::flyteidl::artifact::SearchOptions* p = options_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.options)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::SearchOptions*>(
      &::flyteidl::artifact::_SearchOptions_default_instance_);
}
inline ::flyteidl::artifact::SearchOptions* SearchArtifactsRequest::release_options() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsRequest.options)
  
  ::flyteidl::artifact::SearchOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::SearchOptions* SearchArtifactsRequest::mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::SearchOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsRequest.options)
  return options_;
}
inline void SearchArtifactsRequest::set_allocated_options(::flyteidl::artifact::SearchOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsRequest.options)
}

// string token = 6;
inline void SearchArtifactsRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SearchArtifactsRequest::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.token)
  return token_.GetNoArena();
}
inline void SearchArtifactsRequest::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchArtifactsRequest.token)
}
#if LANG_CXX11
inline void SearchArtifactsRequest::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.SearchArtifactsRequest.token)
}
#endif
inline void SearchArtifactsRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.SearchArtifactsRequest.token)
}
inline void SearchArtifactsRequest::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.SearchArtifactsRequest.token)
}
inline ::std::string* SearchArtifactsRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchArtifactsRequest::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsRequest.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchArtifactsRequest::set_allocated_token(::std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsRequest.token)
}

// int32 limit = 7;
inline void SearchArtifactsRequest::clear_limit() {
  limit_ = 0;
}
inline ::google::protobuf::int32 SearchArtifactsRequest::limit() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.limit)
  return limit_;
}
inline void SearchArtifactsRequest::set_limit(::google::protobuf::int32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchArtifactsRequest.limit)
}

// -------------------------------------------------------------------

// SearchArtifactsResponse

// repeated .flyteidl.artifact.Artifact artifacts = 1;
inline int SearchArtifactsResponse::artifacts_size() const {
  return artifacts_.size();
}
inline void SearchArtifactsResponse::clear_artifacts() {
  artifacts_.Clear();
}
inline ::flyteidl::artifact::Artifact* SearchArtifactsResponse::mutable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return artifacts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >*
SearchArtifactsResponse::mutable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return &artifacts_;
}
inline const ::flyteidl::artifact::Artifact& SearchArtifactsResponse::artifacts(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return artifacts_.Get(index);
}
inline ::flyteidl::artifact::Artifact* SearchArtifactsResponse::add_artifacts() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return artifacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >&
SearchArtifactsResponse::artifacts() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return artifacts_;
}

// string token = 2;
inline void SearchArtifactsResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SearchArtifactsResponse::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsResponse.token)
  return token_.GetNoArena();
}
inline void SearchArtifactsResponse::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchArtifactsResponse.token)
}
#if LANG_CXX11
inline void SearchArtifactsResponse::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.SearchArtifactsResponse.token)
}
#endif
inline void SearchArtifactsResponse::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.SearchArtifactsResponse.token)
}
inline void SearchArtifactsResponse::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.SearchArtifactsResponse.token)
}
inline ::std::string* SearchArtifactsResponse::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsResponse.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchArtifactsResponse::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsResponse.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchArtifactsResponse::set_allocated_token(::std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsResponse.token)
}

// -------------------------------------------------------------------

// FindByWorkflowExecRequest

// .flyteidl.core.WorkflowExecutionIdentifier exec_id = 1;
inline bool FindByWorkflowExecRequest::has_exec_id() const {
  return this != internal_default_instance() && exec_id_ != nullptr;
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& FindByWorkflowExecRequest::exec_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = exec_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.FindByWorkflowExecRequest.exec_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier*>(
      &::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* FindByWorkflowExecRequest::release_exec_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.FindByWorkflowExecRequest.exec_id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = exec_id_;
  exec_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* FindByWorkflowExecRequest::mutable_exec_id() {
  
  if (exec_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaNoVirtual());
    exec_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.FindByWorkflowExecRequest.exec_id)
  return exec_id_;
}
inline void FindByWorkflowExecRequest::set_allocated_exec_id(::flyteidl::core::WorkflowExecutionIdentifier* exec_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(exec_id_);
  }
  if (exec_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      exec_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, exec_id, submessage_arena);
    }
    
  } else {
    
  }
  exec_id_ = exec_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.FindByWorkflowExecRequest.exec_id)
}

// .flyteidl.artifact.FindByWorkflowExecRequest.Direction direction = 2;
inline void FindByWorkflowExecRequest::clear_direction() {
  direction_ = 0;
}
inline ::flyteidl::artifact::FindByWorkflowExecRequest_Direction FindByWorkflowExecRequest::direction() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.FindByWorkflowExecRequest.direction)
  return static_cast< ::flyteidl::artifact::FindByWorkflowExecRequest_Direction >(direction_);
}
inline void FindByWorkflowExecRequest::set_direction(::flyteidl::artifact::FindByWorkflowExecRequest_Direction value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.FindByWorkflowExecRequest.direction)
}

// -------------------------------------------------------------------

// AddTagRequest

// .flyteidl.core.ArtifactID artifact_id = 1;
inline bool AddTagRequest::has_artifact_id() const {
  return this != internal_default_instance() && artifact_id_ != nullptr;
}
inline const ::flyteidl::core::ArtifactID& AddTagRequest::artifact_id() const {
  const ::flyteidl::core::ArtifactID* p = artifact_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.AddTagRequest.artifact_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactID*>(
      &::flyteidl::core::_ArtifactID_default_instance_);
}
inline ::flyteidl::core::ArtifactID* AddTagRequest::release_artifact_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.AddTagRequest.artifact_id)
  
  ::flyteidl::core::ArtifactID* temp = artifact_id_;
  artifact_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactID* AddTagRequest::mutable_artifact_id() {
  
  if (artifact_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactID>(GetArenaNoVirtual());
    artifact_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.AddTagRequest.artifact_id)
  return artifact_id_;
}
inline void AddTagRequest::set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_id_);
  }
  if (artifact_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_id, submessage_arena);
    }
    
  } else {
    
  }
  artifact_id_ = artifact_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.AddTagRequest.artifact_id)
}

// string value = 2;
inline void AddTagRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddTagRequest::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.AddTagRequest.value)
  return value_.GetNoArena();
}
inline void AddTagRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.AddTagRequest.value)
}
#if LANG_CXX11
inline void AddTagRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.AddTagRequest.value)
}
#endif
inline void AddTagRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.AddTagRequest.value)
}
inline void AddTagRequest::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.AddTagRequest.value)
}
inline ::std::string* AddTagRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.AddTagRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddTagRequest::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.AddTagRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddTagRequest::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.AddTagRequest.value)
}

// bool overwrite = 3;
inline void AddTagRequest::clear_overwrite() {
  overwrite_ = false;
}
inline bool AddTagRequest::overwrite() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.AddTagRequest.overwrite)
  return overwrite_;
}
inline void AddTagRequest::set_overwrite(bool value) {
  
  overwrite_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.AddTagRequest.overwrite)
}

// -------------------------------------------------------------------

// AddTagResponse

// -------------------------------------------------------------------

// CreateTriggerRequest

// .flyteidl.admin.LaunchPlan trigger_launch_plan = 1;
inline bool CreateTriggerRequest::has_trigger_launch_plan() const {
  return this != internal_default_instance() && trigger_launch_plan_ != nullptr;
}
inline const ::flyteidl::admin::LaunchPlan& CreateTriggerRequest::trigger_launch_plan() const {
  const ::flyteidl::admin::LaunchPlan* p = trigger_launch_plan_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateTriggerRequest.trigger_launch_plan)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::admin::LaunchPlan*>(
      &::flyteidl::admin::_LaunchPlan_default_instance_);
}
inline ::flyteidl::admin::LaunchPlan* CreateTriggerRequest::release_trigger_launch_plan() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateTriggerRequest.trigger_launch_plan)
  
  ::flyteidl::admin::LaunchPlan* temp = trigger_launch_plan_;
  trigger_launch_plan_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::LaunchPlan* CreateTriggerRequest::mutable_trigger_launch_plan() {
  
  if (trigger_launch_plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::LaunchPlan>(GetArenaNoVirtual());
    trigger_launch_plan_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateTriggerRequest.trigger_launch_plan)
  return trigger_launch_plan_;
}
inline void CreateTriggerRequest::set_allocated_trigger_launch_plan(::flyteidl::admin::LaunchPlan* trigger_launch_plan) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(trigger_launch_plan_);
  }
  if (trigger_launch_plan) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trigger_launch_plan = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger_launch_plan, submessage_arena);
    }
    
  } else {
    
  }
  trigger_launch_plan_ = trigger_launch_plan;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateTriggerRequest.trigger_launch_plan)
}

// -------------------------------------------------------------------

// CreateTriggerResponse

// -------------------------------------------------------------------

// DeactivateTriggerRequest

// .flyteidl.core.Identifier trigger_id = 1;
inline bool DeactivateTriggerRequest::has_trigger_id() const {
  return this != internal_default_instance() && trigger_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& DeactivateTriggerRequest::trigger_id() const {
  const ::flyteidl::core::Identifier* p = trigger_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.DeactivateTriggerRequest.trigger_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* DeactivateTriggerRequest::release_trigger_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.DeactivateTriggerRequest.trigger_id)
  
  ::flyteidl::core::Identifier* temp = trigger_id_;
  trigger_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* DeactivateTriggerRequest::mutable_trigger_id() {
  
  if (trigger_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    trigger_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.DeactivateTriggerRequest.trigger_id)
  return trigger_id_;
}
inline void DeactivateTriggerRequest::set_allocated_trigger_id(::flyteidl::core::Identifier* trigger_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(trigger_id_);
  }
  if (trigger_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trigger_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger_id, submessage_arena);
    }
    
  } else {
    
  }
  trigger_id_ = trigger_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.DeactivateTriggerRequest.trigger_id)
}

// -------------------------------------------------------------------

// DeactivateTriggerResponse

// -------------------------------------------------------------------

// ArtifactProducer

// .flyteidl.core.Identifier entity_id = 1;
inline bool ArtifactProducer::has_entity_id() const {
  return this != internal_default_instance() && entity_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& ArtifactProducer::entity_id() const {
  const ::flyteidl::core::Identifier* p = entity_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactProducer.entity_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* ArtifactProducer::release_entity_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactProducer.entity_id)
  
  ::flyteidl::core::Identifier* temp = entity_id_;
  entity_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ArtifactProducer::mutable_entity_id() {
  
  if (entity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    entity_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactProducer.entity_id)
  return entity_id_;
}
inline void ArtifactProducer::set_allocated_entity_id(::flyteidl::core::Identifier* entity_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(entity_id_);
  }
  if (entity_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entity_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_id, submessage_arena);
    }
    
  } else {
    
  }
  entity_id_ = entity_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactProducer.entity_id)
}

// .flyteidl.core.VariableMap outputs = 2;
inline bool ArtifactProducer::has_outputs() const {
  return this != internal_default_instance() && outputs_ != nullptr;
}
inline const ::flyteidl::core::VariableMap& ArtifactProducer::outputs() const {
  const ::flyteidl::core::VariableMap* p = outputs_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactProducer.outputs)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::VariableMap*>(
      &::flyteidl::core::_VariableMap_default_instance_);
}
inline ::flyteidl::core::VariableMap* ArtifactProducer::release_outputs() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactProducer.outputs)
  
  ::flyteidl::core::VariableMap* temp = outputs_;
  outputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::VariableMap* ArtifactProducer::mutable_outputs() {
  
  if (outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::VariableMap>(GetArenaNoVirtual());
    outputs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactProducer.outputs)
  return outputs_;
}
inline void ArtifactProducer::set_allocated_outputs(::flyteidl::core::VariableMap* outputs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(outputs_);
  }
  if (outputs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      outputs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, outputs, submessage_arena);
    }
    
  } else {
    
  }
  outputs_ = outputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactProducer.outputs)
}

// -------------------------------------------------------------------

// RegisterProducerRequest

// repeated .flyteidl.artifact.ArtifactProducer producers = 1;
inline int RegisterProducerRequest::producers_size() const {
  return producers_.size();
}
inline void RegisterProducerRequest::clear_producers() {
  producers_.Clear();
}
inline ::flyteidl::artifact::ArtifactProducer* RegisterProducerRequest::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >*
RegisterProducerRequest::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.RegisterProducerRequest.producers)
  return &producers_;
}
inline const ::flyteidl::artifact::ArtifactProducer& RegisterProducerRequest::producers(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_.Get(index);
}
inline ::flyteidl::artifact::ArtifactProducer* RegisterProducerRequest::add_producers() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >&
RegisterProducerRequest::producers() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_;
}

// -------------------------------------------------------------------

// ArtifactConsumer

// .flyteidl.core.Identifier entity_id = 1;
inline bool ArtifactConsumer::has_entity_id() const {
  return this != internal_default_instance() && entity_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& ArtifactConsumer::entity_id() const {
  const ::flyteidl::core::Identifier* p = entity_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactConsumer.entity_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* ArtifactConsumer::release_entity_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactConsumer.entity_id)
  
  ::flyteidl::core::Identifier* temp = entity_id_;
  entity_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ArtifactConsumer::mutable_entity_id() {
  
  if (entity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    entity_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactConsumer.entity_id)
  return entity_id_;
}
inline void ArtifactConsumer::set_allocated_entity_id(::flyteidl::core::Identifier* entity_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(entity_id_);
  }
  if (entity_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entity_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_id, submessage_arena);
    }
    
  } else {
    
  }
  entity_id_ = entity_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactConsumer.entity_id)
}

// .flyteidl.core.ParameterMap inputs = 2;
inline bool ArtifactConsumer::has_inputs() const {
  return this != internal_default_instance() && inputs_ != nullptr;
}
inline const ::flyteidl::core::ParameterMap& ArtifactConsumer::inputs() const {
  const ::flyteidl::core::ParameterMap* p = inputs_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactConsumer.inputs)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ParameterMap*>(
      &::flyteidl::core::_ParameterMap_default_instance_);
}
inline ::flyteidl::core::ParameterMap* ArtifactConsumer::release_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactConsumer.inputs)
  
  ::flyteidl::core::ParameterMap* temp = inputs_;
  inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ParameterMap* ArtifactConsumer::mutable_inputs() {
  
  if (inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ParameterMap>(GetArenaNoVirtual());
    inputs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactConsumer.inputs)
  return inputs_;
}
inline void ArtifactConsumer::set_allocated_inputs(::flyteidl::core::ParameterMap* inputs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(inputs_);
  }
  if (inputs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inputs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactConsumer.inputs)
}

// -------------------------------------------------------------------

// RegisterConsumerRequest

// repeated .flyteidl.artifact.ArtifactConsumer consumers = 1;
inline int RegisterConsumerRequest::consumers_size() const {
  return consumers_.size();
}
inline void RegisterConsumerRequest::clear_consumers() {
  consumers_.Clear();
}
inline ::flyteidl::artifact::ArtifactConsumer* RegisterConsumerRequest::mutable_consumers(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >*
RegisterConsumerRequest::mutable_consumers() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return &consumers_;
}
inline const ::flyteidl::artifact::ArtifactConsumer& RegisterConsumerRequest::consumers(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_.Get(index);
}
inline ::flyteidl::artifact::ArtifactConsumer* RegisterConsumerRequest::add_consumers() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >&
RegisterConsumerRequest::consumers() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_;
}

// -------------------------------------------------------------------

// RegisterResponse

// -------------------------------------------------------------------

// ExecutionInputsRequest

// .flyteidl.core.WorkflowExecutionIdentifier execution_id = 1;
inline bool ExecutionInputsRequest::has_execution_id() const {
  return this != internal_default_instance() && execution_id_ != nullptr;
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ExecutionInputsRequest::execution_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = execution_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ExecutionInputsRequest.execution_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier*>(
      &::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionInputsRequest::release_execution_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ExecutionInputsRequest.execution_id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = execution_id_;
  execution_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ExecutionInputsRequest::mutable_execution_id() {
  
  if (execution_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaNoVirtual());
    execution_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ExecutionInputsRequest.execution_id)
  return execution_id_;
}
inline void ExecutionInputsRequest::set_allocated_execution_id(::flyteidl::core::WorkflowExecutionIdentifier* execution_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(execution_id_);
  }
  if (execution_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      execution_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, execution_id, submessage_arena);
    }
    
  } else {
    
  }
  execution_id_ = execution_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ExecutionInputsRequest.execution_id)
}

// repeated .flyteidl.core.ArtifactID inputs = 2;
inline int ExecutionInputsRequest::inputs_size() const {
  return inputs_.size();
}
inline ::flyteidl::core::ArtifactID* ExecutionInputsRequest::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ExecutionInputsRequest.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID >*
ExecutionInputsRequest::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.ExecutionInputsRequest.inputs)
  return &inputs_;
}
inline const ::flyteidl::core::ArtifactID& ExecutionInputsRequest::inputs(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ExecutionInputsRequest.inputs)
  return inputs_.Get(index);
}
inline ::flyteidl::core::ArtifactID* ExecutionInputsRequest::add_inputs() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.ExecutionInputsRequest.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID >&
ExecutionInputsRequest::inputs() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.ExecutionInputsRequest.inputs)
  return inputs_;
}

// -------------------------------------------------------------------

// ExecutionInputsResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace artifact
}  // namespace flyteidl

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::flyteidl::artifact::FindByWorkflowExecRequest_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::artifact::FindByWorkflowExecRequest_Direction>() {
  return ::flyteidl::artifact::FindByWorkflowExecRequest_Direction_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fartifact_2fartifacts_2eproto
